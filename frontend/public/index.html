<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <h2></h2>
    <title>University Schedule Creator</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            padding: 2rem;
            max-height: 100vh;
            overflow: hidden;
        }
        
        .left-column {
            flex: 0.7;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }
        
        .right-column {
            flex: 1.3;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }
        
        .page-title {
            text-align: center;
            margin: 0 0 2rem 0;
            font-size: 28px;
            color: #333;
            font-weight: bold;
        }
        
        .search-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .search-container h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            border-color: #007bff;
            outline: none;
        }
        
        .lecture-list {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }
        
        .lecture-item {
            margin: 8px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            transition: all 0.2s;
        }
        
        .lecture-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0,123,255,0.15);
        }
        
        .selected-lectures-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .selected-lectures-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .combinations-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .combinations-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .selected-lecture-tag {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-radius: 20px;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }
        
        .remove-btn {
            margin-left: 8px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        
        .remove-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .timetable {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .timetable-section {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .timetable-section h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 22px;
            text-align: center;
        }
        
        .timetable-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin: 0;
            flex: 1;
        }
        
        .timetable-grid {
            display: grid;
            grid-template-columns: 120px repeat(5, 1fr);
            grid-template-rows: 60px repeat(11, 60px);
            gap: 1px;
            background-color: #e2e8f0;
            font-family: 'Arial', sans-serif;
        }
        
        .timetable-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            padding: 10px;
        }
        
        .time-slot {
            background: #f8fafc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #4a5568;
            font-size: 14px;
            border-right: 2px solid #e2e8f0;
        }
        
        .timetable-cell {
            background: #ffffff;
            position: relative;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
            min-height: 58px;
            cursor: pointer;
        }
        
        .timetable-cell:hover {
            background: #f7fafc;
            transform: scale(1.02);
            z-index: 1;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .timetable-cell.locked {
            background: #fed7d7 !important;
            border: 2px solid #e53e3e !important;
            cursor: pointer;
        }
        
        .timetable-cell.locked:hover {
            background: #feb2b2 !important;
            transform: scale(1.02);
        }
        
        .locked-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #e53e3e;
            pointer-events: none;
        }
        
        .lecture-block {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border-radius: 8px;
            padding: 8px;
            color: white;
            font-size: 11px;
            line-height: 1.2;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        .lecture-block:hover {
            transform: scale(1.02);
            z-index: 20;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .lecture-block.multi-row {
            position: absolute;
            border-radius: 8px;
            padding: 12px 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        
        .occupied-continuation {
            background-color: transparent !important;
            border: none !important;
            position: relative;
            z-index: 5;
        }
        
        .lecture-code {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 2px;
        }
        
        .lecture-section {
            font-size: 10px;
            opacity: 0.9;
            margin-bottom: 2px;
        }
        
        .lecture-lecturer {
            font-size: 9px;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .lecture-continuation {
            background: linear-gradient(135deg, #4299e1, #3182ce) !important;
            justify-content: center;
            align-items: center;
        }
        
        .lecture-colors {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        
        .lecture-colors-alt {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }
        
        .lecture-colors-alt2 {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }
        
        .lecture-colors-alt3 {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
        }
        
        .lecture-colors-alt4 {
            background: linear-gradient(135deg, #fa709a, #fee140);
        }
        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                max-height: none;
                overflow: visible;
            }
            
            .left-column,
            .right-column {
                max-height: none;
                overflow-y: visible;
            }
            
            .timetable-grid {
                grid-template-columns: 80px repeat(5, 1fr);
                grid-template-rows: 50px repeat(11, 50px);
                font-size: 12px;
            }
            
            .timetable-header {
                font-size: 14px;
                padding: 8px;
            }
            
            .time-slot {
                font-size: 12px;
            }
            
            .lecture-block {
                padding: 4px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
        <div id="root"></div>
        <h1 class="page-title">University Schedule Creator</h1>
        
        <div class="main-container">
            <!-- Left Column -->
            <div class="left-column">
                <!-- Search and Lecture Selection Section -->
                <div class="search-container">
                    <h2>Search and Select Lectures</h2>
                    <div style="margin-bottom: 1rem;">
                        <input type="text" id="lectureSearch" placeholder="Search for lectures, codes, or lecturers..." 
                               class="search-input">
                    </div>
                    
                    <div id="lectureList" class="lecture-list" style="padding: 10px;">
                        <div id="loadingMessage" style="text-align: center; color: #666;">Loading lectures...</div>
                        <div id="lectureResults"></div>
                    </div>
                </div>
                
                <!-- Conflict Settings Section -->
                <div class="conflict-settings-container" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px; border: 1px solid #e9ecef;">
                    <h3 style="margin: 0 0 15px 0; color: #495057;">Conflict Settings</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label for="maxConflicts" style="font-weight: 500; color: #495057;">Maximum Conflicting Hours Allowed:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="range" id="maxConflicts" min="0" max="10" value="0" 
                                   style="flex: 1;" onchange="updateConflictSettings()">
                            <span id="conflictValue" style="font-weight: bold; color: #007bff; min-width: 30px;">0</span>
                        </div>
                        <small style="color: #6c757d;">Set to 0 for no conflicts (default), increase to allow overlapping lectures</small>
                    </div>
                </div>
                
                <!-- Possible Timetable Combinations -->
                <div id="timetableCombinations" class="combinations-container" style="display: none;">
                    <h3>Possible Timetable Combinations:</h3>
                    <div id="combinationsContainer" style="flex: 1; overflow-y: auto;">
                    </div>
                </div>
            </div>
            
            <!-- Right Column -->
            <div class="right-column">
                <!-- Selected Lectures -->
                <div class="selected-lectures-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Selected Lectures:</h3>
                        <button id="minimizeSelectedButton" onclick="toggleSelectedLecturesVisibility()" 
                                style="background: #6c757d; color: white; border: none; border-radius: 6px; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: all 0.2s ease;"
                                onmouseover="this.style.background='#5a6268'" onmouseout="this.style.background='#6c757d'">
                            ▲
                        </button>
                    </div>
                    <div id="selectedLectures" style="min-height: 50px;">
                        <p style="color: #666; margin: 0;">No lectures selected yet.</p>
                    </div>
                </div>
                
                <!-- Locked Time Slots -->
                <div id="lockedSlotsContainer" class="selected-lectures-container" style="display: none;">
                    <h3>Locked Time Slots:</h3>
                    <div id="lockedSlots" style="min-height: 30px;">
                        <p style="color: #666; margin: 0; font-size: 14px;">Click on empty timetable cells to lock them.</p>
                    </div>
                    <button onclick="clearAllLockedSlots()" style="margin-top: 10px; padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Clear All Locked Slots
                    </button>
                </div>
                
                <!-- Timetable Controls -->
                <div id="timetableControls" style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: none;">
                    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <label style="font-weight: bold; margin-right: 10px;">Timetable Combination:</label>
                            <select id="combinationSelector" onchange="displayCombinationInTimetable()" style="padding: 8px; border: 2px solid #e0e0e0; border-radius: 5px; background: white;">
                                <option value="">Select a combination...</option>
                            </select>
                        </div>
                        <div style="color: #666; font-size: 14px;">
                            <span id="combinationInfo"></span>
                        </div>
                    </div>
                </div>
                
                <!-- Weekly Timetable -->
                <div class="timetable-section">
                    <h2>Weekly Timetable</h2>
                    
                    <div class="timetable-container">
                        <div class="timetable-grid" id="timetableGrid">
                            <!-- Timetable will be generated dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <script>
        // Lecture data and functionality
        let allLectures = [];
        let selectedLectures = [];
        let validCombinations = [];
        let currentCombinationIndex = 0;
        let lockedTimeSlots = new Set(); // Format: "Day_Hour" (e.g., "Monday_10")
        let lecturerPreferences = {}; // Object to store preferred lecturers for each lecture code
        let sectionPreferences = {}; // Object to store preferred sections for each lecture code
        let lectureColors = {}; // Object to store assigned colors for each lecture code
        
        // Simple time structure - each hour from 9 to 19
        const timeHours = [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
        const days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        const dayColumnMap = {
            "Monday": 1,
            "Tuesday": 2, 
            "Wednesday": 3,
            "Thursday": 4,
            "Friday": 5
        };
        
        // Process lectures to parse time slots from Excel format
        function processLectures(rawLectures) {
            const processedLectures = [];
            
            rawLectures.forEach(lecture => {
                const timeSlots = parseExcelTime(lecture.ExcelTime);
                
                if (timeSlots.length === 0) {
                    console.warn('No valid time slots found for lecture:', lecture);
                    return;
                }
                
                // Create a lecture entry for each time slot
                timeSlots.forEach((timeSlot, index) => {
                    processedLectures.push({
                        ...lecture,
                        Day: timeSlot.Day,
                        StartHour: timeSlot.StartHour,
                        EndHour: timeSlot.EndHour,
                        TimeSlotIndex: index // To track multiple slots for same lecture
                    });
                });
            });
            
            return processedLectures;
        }
        
        // Color generation and assignment functions
        function generateRandomColor() {
            const colors = [
                { bg: 'linear-gradient(135deg, #667eea, #764ba2)', text: 'white' },
                { bg: 'linear-gradient(135deg, #f093fb, #f5576c)', text: 'white' },
                { bg: 'linear-gradient(135deg, #4facfe, #00f2fe)', text: 'white' },
                { bg: 'linear-gradient(135deg, #43e97b, #38f9d7)', text: 'white' },
                { bg: 'linear-gradient(135deg, #fa709a, #fee140)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ff9a9e, #fecfef)', text: 'white' },
                { bg: 'linear-gradient(135deg, #a18cd1, #fbc2eb)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffecd2, #fcb69f)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ff8a80, #ff5722)', text: 'white' },
                { bg: 'linear-gradient(135deg, #81c784, #4caf50)', text: 'white' },
                { bg: 'linear-gradient(135deg, #64b5f6, #2196f3)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ba68c8, #9c27b0)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffb74d, #ff9800)', text: 'white' },
                { bg: 'linear-gradient(135deg, #4db6ac, #009688)', text: 'white' },
                { bg: 'linear-gradient(135deg, #f06292, #e91e63)', text: 'white' },
                { bg: 'linear-gradient(135deg, #aed581, #8bc34a)', text: 'white' },
                { bg: 'linear-gradient(135deg, #90a4ae, #607d8b)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffcc02, #ffc107)', text: 'white' },
                { bg: 'linear-gradient(135deg, #26c6da, #00bcd4)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ab47bc, #8e24aa)', text: 'white' }
            ];
            
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function assignLectureColor(lectureCode) {
            if (!lectureColors[lectureCode]) {
                lectureColors[lectureCode] = generateRandomColor();
                console.log(`Assigned color to ${lectureCode}:`, lectureColors[lectureCode]);
            }
            return lectureColors[lectureCode];
        }
        
        function getLectureColor(lectureCode) {
            return lectureColors[lectureCode] || { bg: 'linear-gradient(135deg, #667eea, #764ba2)', text: 'white' };
        }
        
        // Day name mapping
        const dayMapping = {
            'Mo': 'Monday',
            'Tu': 'Tuesday', 
            'We': 'Wednesday',
            'Th': 'Thursday',
            'Fr': 'Friday'
        };
        
        // Parse Excel time format like "Fr 13 - 16" or "Tu/Fr 09 - 12 Tu/Fr 13 - 15"
        function parseExcelTime(timeString) {
            if (!timeString) return [];
            
            const timeSlots = [];
            
            // Handle complex patterns like "Tu/Fr 09 - 12 Tu/Fr 13 - 15"
            // First, split by multiple consecutive spaces to separate different time blocks
            let timeBlocks = timeString.split(/\s{2,}/).filter(block => block.trim());
            
            // If no multiple spaces found, treat as single block
            if (timeBlocks.length <= 1) {
                timeBlocks = [timeString];
            }
            
            timeBlocks.forEach(block => {
                // Handle patterns like "Tu/Fr 09 - 12" (multiple days with same time)
                const dayTimeMatch = block.match(/([A-Za-z]{2}(?:\/[A-Za-z]{2})*)\s+(\d{1,2})\s*-\s*(\d{1,2})/);
                
                if (dayTimeMatch) {
                    const [, dayPart, startHour, endHour] = dayTimeMatch;
                    const days = dayPart.split('/'); // Split multiple days like "Tu/Fr"
                    
                    days.forEach(dayAbbr => {
                        const fullDay = dayMapping[dayAbbr.trim()];
                        if (fullDay) {
                            timeSlots.push({
                                Day: fullDay,
                                StartHour: parseInt(startHour),
                                EndHour: parseInt(endHour)
                            });
                        }
                    });
                } else {
                    // Handle simple patterns like "Mo 11 - 13" or multiple separate day-time pairs
                    const simplePatterns = block.match(/[A-Za-z]{2}\s+\d{1,2}\s*-\s*\d{1,2}/g);
                    
                    if (simplePatterns) {
                        simplePatterns.forEach(pattern => {
                            const match = pattern.match(/([A-Za-z]{2})\s+(\d{1,2})\s*-\s*(\d{1,2})/);
                            if (match) {
                                const [, dayAbbr, startHour, endHour] = match;
                                const fullDay = dayMapping[dayAbbr];
                                if (fullDay) {
                                    timeSlots.push({
                                        Day: fullDay,
                                        StartHour: parseInt(startHour),
                                        EndHour: parseInt(endHour)
                                    });
                                }
                            }
                        });
                    }
                }
            });
            
            return timeSlots;
        }
        
        // Sample lecture data with Excel-like time format (matching real Excel structure)
        const sampleLectures = [
            { Code: "ADA 403", Name: "Exploratory Data Analysis", Lecturer: "", Hours: "3", Section: "01", ExcelTime: "Fr 13 - 16" },
            { Code: "ADA 423", Name: "Statistical Inference Methods with Applications", Lecturer: "Şafak Özden", Hours: "3", Section: "01", ExcelTime: "Th 11 - 14" },
            { Code: "ARCH 101", Name: "Basics of Design", Lecturer: "Gökhan Kınayoğlu", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 13 - 15 Tu/Fr 09 - 12" },
            { Code: "ARCH 111", Name: "Architectural Communication Techniques I", Lecturer: "Başak Uçar Kırmızıgöl", Hours: "3", Section: "01", ExcelTime: "Th 09 - 13" },
            { Code: "ARCH 121", Name: "Introduction to Architecture", Lecturer: "Bilge İmamoğlu", Hours: "3", Section: "01", ExcelTime: "We 09 - 12" },
            { Code: "ARCH 201", Name: "Architectural Design I", Lecturer: "Zuhal Acar Metin", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 09 - 12 Tu/Fr 13 - 15" },
            { Code: "ARCH 301", Name: "Architectural Design III", Lecturer: "Azize Elif Yabacı", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 09 - 12 Tu/Fr 13 - 15" },
            { Code: "ARCH 301-O", Name: "Architectural Design III", Lecturer: "Gültekin Doruk Atay", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 13 - 15 Tu/Fr 09 - 12" },
            { Code: "ARCH 381", Name: "Urban Design", Lecturer: "Seray Türkay Coşkun", Hours: "3", Section: "01", ExcelTime: "Mo 09 - 13" },
            { Code: "BA 305", Name: "Production and Operations Management", Lecturer: "Hakan Bütüner", Hours: "3", Section: "01", ExcelTime: "Mo 12 - 15 Th 17 - 18" },
            { Code: "CE 214", Name: "Introduction to Mechanics of Materials", Lecturer: "Rıza Secer Orkun Keskin", Hours: "4", Section: "01", ExcelTime: "Tu 14 - 16 We 14 - 15 Fr 15 - 17" },
            { Code: "CE 331", Name: "Hydromechanics", Lecturer: "Aslı Numanoğlu Genç", Hours: "4", Section: "01", ExcelTime: "We 15 - 16 Th 12 - 14 Fr 13 - 15" }
        ];
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            initializeTimetable();
            loadLectures();
            setupSearchFunctionality();
        });
        
        // Initialize empty timetable
        function initializeTimetable() {
            const timetableGrid = document.getElementById('timetableGrid');
            
            // Create CSS Grid layout
            let gridHTML = '';
            
            // Headers
            gridHTML += '<div class="timetable-header">Time</div>';
            gridHTML += '<div class="timetable-header">Monday</div>';
            gridHTML += '<div class="timetable-header">Tuesday</div>';
            gridHTML += '<div class="timetable-header">Wednesday</div>';
            gridHTML += '<div class="timetable-header">Thursday</div>';
            gridHTML += '<div class="timetable-header">Friday</div>';
            
            // Time slots and cells
            timeHours.forEach(hour => {
                const nextHour = hour + 1;
                const timeLabel = `${hour.toString().padStart(2, '0')}:00 - ${nextHour.toString().padStart(2, '0')}:00`;
                
                // Time slot
                gridHTML += `<div class="time-slot">${timeLabel}</div>`;
                
                // Day cells with click handlers
                days.forEach(day => {
                    gridHTML += `<div class="timetable-cell" id="cell_${day}_${hour}" onclick="toggleTimeSlotLock('${day}', ${hour})"></div>`;
                });
            });
            
            timetableGrid.innerHTML = gridHTML;
            console.log('Modern timetable initialized with CSS Grid and click handlers');
        }
        
        // Load lectures from API or use sample data
        async function loadLectures() {
            try {
                const response = await fetch('http://localhost:5000/api/lectures');
                if (response.ok) {
                    const rawLectures = await response.json();
                    allLectures = processLectures(rawLectures);
                } else {
                    throw new Error('API not available');
                }
            } catch (error) {
                console.log('Using sample data - API not available');
                allLectures = processLectures(sampleLectures);
            }
            
            console.log('Processed lectures:', allLectures);
            document.getElementById('loadingMessage').style.display = 'none';
            displayLectures(allLectures);
        }
        
        // Setup search functionality
        function setupSearchFunctionality() {
            const searchInput = document.getElementById('lectureSearch');
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase().normalize('NFD');
                const filteredLectures = allLectures.filter(lecture => 
                    lecture.Code.toLowerCase().normalize('NFD').includes(searchTerm) ||
                    lecture.Name.toLowerCase().normalize('NFD').includes(searchTerm) ||
                    (lecture.Lecturer && lecture.Lecturer.toLowerCase().normalize('NFD').includes(searchTerm))
                );
                displayLectures(filteredLectures);
            });
        }
        
        // Display lectures in the list
        function displayLectures(lectures) {
            const resultsContainer = document.getElementById('lectureResults');
            
            if (lectures.length === 0) {
                resultsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No lectures found.</p>';
                return;
            }
            
            // Group lectures by code and name only (merge all sections)
            const lecturesByCode = {};
            lectures.forEach(lecture => {
                const key = lecture.Code; // Group by code only
                if (!lecturesByCode[key]) {
                    lecturesByCode[key] = {
                        Code: lecture.Code,
                        Name: lecture.Name,
                        Hours: lecture.Hours,
                        sections: []
                    };
                }
                
                // Find or create section within this lecture
                let existingSection = lecturesByCode[key].sections.find(s => s.Section === lecture.Section);
                if (!existingSection) {
                    existingSection = {
                        Section: lecture.Section,
                        Lecturer: lecture.Lecturer,
                        ExcelTime: lecture.ExcelTime,
                        timeSlots: []
                    };
                    lecturesByCode[key].sections.push(existingSection);
                }
                
                // Add time slot to section
                existingSection.timeSlots.push({
                    Day: lecture.Day,
                    StartHour: lecture.StartHour,
                    EndHour: lecture.EndHour
                });
            });
            
            resultsContainer.innerHTML = Object.values(lecturesByCode).map(lecture => `
                <div class="lecture-item">
                    <label style="display: flex; align-items: flex-start; cursor: pointer;">
                        <input type="checkbox" value="${lecture.Code}" onchange="toggleLectureSelection('${lecture.Code}')" 
                               style="margin-right: 15px; margin-top: 5px; transform: scale(1.3);"
                               ${selectedLectures.some(selected => selected.Code === lecture.Code) ? 'checked' : ''}>
                        <div style="flex: 1;">
                            <div><strong style="color: #007bff; font-size: 16px;">${lecture.Code}</strong> - ${lecture.Name}</div>
                            <div style="color: #666; margin: 8px 0;">Hours: ${lecture.Hours}</div>
                            <div style="margin-top: 10px;">
                                <strong style="color: #333; font-size: 14px;">Available Sections:</strong>
                                <div style="margin-top: 5px;">
                                    ${lecture.sections.map(section => `
                                        <div style="background: #f8f9fa; padding: 8px; margin: 4px 0; border-radius: 5px; border-left: 3px solid #007bff;">
                                            <span style="font-weight: bold;">Section ${section.Section}</span> - ${section.Lecturer}<br>
                                            <span style="color: #666; font-size: 12px;">Excel Time: ${section.ExcelTime}</span><br>
                                            ${section.timeSlots.map(slot => 
                                                `<span style="color: #28a745; font-weight: bold; display: inline-block; margin-right: 10px;">${slot.Day} ${slot.StartHour}:00-${slot.EndHour}:00</span>`
                                            ).join('')}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    </label>
                </div>
            `).join('');
        }
        
        // Toggle lecture selection
        function toggleLectureSelection(lectureCode) {
            const lecturesWithCode = allLectures.filter(l => l.Code === lectureCode);
            const existingIndex = selectedLectures.findIndex(l => l.Code === lectureCode);
            
            if (existingIndex > -1) {
                selectedLectures.splice(existingIndex, 1);
                // Remove both lecturer and section preferences when lecture is deselected
                delete lecturerPreferences[lectureCode];
                delete sectionPreferences[lectureCode];
                // Remove color assignment when lecture is deselected
                delete lectureColors[lectureCode];
            } else {
                // Add the first occurrence (we'll show all sections in combinations)
                selectedLectures.push(lecturesWithCode[0]);
                // Assign a random color to the newly selected lecture
                assignLectureColor(lectureCode);
            }
            
            updateSelectedLecturesDisplay();
            generateTimetableCombinations();
        }
        
        // Update lecturer preference for a specific lecture
        function updateLecturerPreference(lectureCode, preferredLecturer) {
            console.log(`Updating lecturer preference for ${lectureCode} to ${preferredLecturer}`);
            
            if (preferredLecturer === 'any') {
                delete lecturerPreferences[lectureCode];
            } else {
                lecturerPreferences[lectureCode] = preferredLecturer;
            }
            
            // Regenerate combinations if we have selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Open lecture filter popup
        function openLectureFilterPopup(lectureCode) {
            const lecture = selectedLectures.find(l => l.Code === lectureCode);
            if (!lecture) return;
            
            // Get all sections for this lecture with their details
            const sections = {};
            allLectures.forEach(l => {
                if (l.Code === lectureCode) {
                    if (!sections[l.Section]) {
                        sections[l.Section] = {
                            section: l.Section,
                            lecturer: l.Lecturer || 'TBA',
                            excelTime: l.ExcelTime,
                            timeSlots: []
                        };
                    }
                    sections[l.Section].timeSlots.push({
                        day: l.Day,
                        startHour: l.StartHour,
                        endHour: l.EndHour
                    });
                }
            });
            
            const sectionList = Object.values(sections);
            const allLecturers = [...new Set(sectionList.map(s => s.lecturer).filter(l => l && l !== 'TBA'))];
            
            const currentLecturerPref = lecturerPreferences[lectureCode] || [];
            const currentSectionPref = sectionPreferences[lectureCode] || [];
            
            // Create popup HTML
            const popupHTML = `
                <div id="lectureFilterOverlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center;" onclick="closeLectureFilterPopup()">
                    <div style="background: white; border-radius: 12px; padding: 24px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3);" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0; color: #333;">🎯 Filter: ${lectureCode} - ${lecture.Name}</h3>
                            <button onclick="closeLectureFilterPopup()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">×</button>
                        </div>
                        
                        <!-- Lecturer Filter Section -->
                        <div style="margin-bottom: 24px;">
                            <h4 style="margin: 0 0 12px 0; color: #495057;">Select Lecturers:</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;">
                                ${allLecturers.map(lecturer => `
                                    <label style="display: flex; align-items: center; background: #f8f9fa; padding: 8px 12px; border-radius: 20px; cursor: pointer; transition: all 0.2s; border: 1px solid #dee2e6;" 
                                           onmouseover="this.style.backgroundColor='#e9ecef'" onmouseout="this.style.backgroundColor='#f8f9fa'">
                                        <input type="checkbox" value="${lecturer}" ${currentLecturerPref.includes(lecturer) ? 'checked' : ''} 
                                               onchange="toggleLecturerFilter('${lectureCode}', '${lecturer}', this.checked)" 
                                               style="margin-right: 8px;">
                                        <span style="font-size: 13px;">${lecturer}</span>
                                    </label>
                                `).join('')}
                            </div>
                            <button onclick="selectAllLecturers('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">Select All</button>
                            <button onclick="clearAllLecturers('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear All</button>
                        </div>
                        
                        <!-- Section Filter Section -->
                        <div style="margin-bottom: 24px;">
                            <h4 style="margin: 0 0 12px 0; color: #495057;">Select Sections:</h4>
                            <div style="display: grid; gap: 12px;">
                                ${sectionList.map(section => `
                                    <label style="display: flex; align-items: flex-start; background: #f8f9fa; padding: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid #dee2e6;" 
                                           onmouseover="this.style.backgroundColor='#e9ecef'" onmouseout="this.style.backgroundColor='#f8f9fa'">
                                        <input type="checkbox" value="${section.section}" ${currentSectionPref.includes(section.section) ? 'checked' : ''} 
                                               onchange="toggleSectionFilter('${lectureCode}', '${section.section}', this.checked)" 
                                               style="margin-right: 12px; margin-top: 2px;">
                                        <div style="flex: 1;">
                                            <div style="font-weight: bold; color: #007bff; margin-bottom: 4px;">Section ${section.section}</div>
                                            <div style="font-size: 13px; color: #666; margin-bottom: 4px;">Lecturer: ${section.lecturer}</div>
                                            <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Schedule: ${section.excelTime}</div>
                                            <div style="font-size: 11px; color: #28a745;">
                                                ${section.timeSlots.map(slot => `${slot.day} ${slot.startHour}:00-${slot.endHour}:00`).join(' | ')}
                                            </div>
                                        </div>
                                    </label>
                                `).join('')}
                            </div>
                            <div style="margin-top: 12px;">
                                <button onclick="selectAllSections('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">Select All</button>
                                <button onclick="clearAllSections('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear All</button>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; justify-content: flex-end; gap: 12px; padding-top: 12px; border-top: 1px solid #dee2e6;">
                            <button onclick="clearAllFilters('${lectureCode}')" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;">Clear All Filters</button>
                            <button onclick="applyFiltersAndClose('${lectureCode}')" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">Apply Filters</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add popup to DOM
            document.body.insertAdjacentHTML('beforeend', popupHTML);
        }
        
        // Close lecture filter popup
        function closeLectureFilterPopup() {
            const overlay = document.getElementById('lectureFilterOverlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Toggle lecturer filter
        function toggleLecturerFilter(lectureCode, lecturer, isChecked) {
            if (!lecturerPreferences[lectureCode]) {
                lecturerPreferences[lectureCode] = [];
            }
            
            if (isChecked) {
                if (!lecturerPreferences[lectureCode].includes(lecturer)) {
                    lecturerPreferences[lectureCode].push(lecturer);
                }
            } else {
                lecturerPreferences[lectureCode] = lecturerPreferences[lectureCode].filter(l => l !== lecturer);
                if (lecturerPreferences[lectureCode].length === 0) {
                    delete lecturerPreferences[lectureCode];
                }
            }
        }
        
        // Toggle section filter
        function toggleSectionFilter(lectureCode, section, isChecked) {
            if (!sectionPreferences[lectureCode]) {
                sectionPreferences[lectureCode] = [];
            }
            
            if (isChecked) {
                if (!sectionPreferences[lectureCode].includes(section)) {
                    sectionPreferences[lectureCode].push(section);
                }
            } else {
                sectionPreferences[lectureCode] = sectionPreferences[lectureCode].filter(s => s !== section);
                if (sectionPreferences[lectureCode].length === 0) {
                    delete sectionPreferences[lectureCode];
                }
            }
        }
        
        // Select all lecturers for a lecture
        function selectAllLecturers(lectureCode) {
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            const lecturerCheckboxes = Array.from(checkboxes).filter(cb => {
                return allLectures.some(l => l.Code === lectureCode && l.Lecturer === cb.value);
            });
            
            lecturerPreferences[lectureCode] = [];
            lecturerCheckboxes.forEach(cb => {
                cb.checked = true;
                if (!lecturerPreferences[lectureCode].includes(cb.value)) {
                    lecturerPreferences[lectureCode].push(cb.value);
                }
            });
        }
        
        // Clear all lecturers for a lecture
        function clearAllLecturers(lectureCode) {
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            const lecturerCheckboxes = Array.from(checkboxes).filter(cb => {
                return allLectures.some(l => l.Code === lectureCode && l.Lecturer === cb.value);
            });
            
            lecturerCheckboxes.forEach(cb => cb.checked = false);
            delete lecturerPreferences[lectureCode];
        }
        
        // Select all sections for a lecture
        function selectAllSections(lectureCode) {
            const sections = [...new Set(allLectures.filter(l => l.Code === lectureCode).map(l => l.Section))];
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            
            sectionPreferences[lectureCode] = [];
            checkboxes.forEach(cb => {
                if (sections.includes(cb.value)) {
                    cb.checked = true;
                    if (!sectionPreferences[lectureCode].includes(cb.value)) {
                        sectionPreferences[lectureCode].push(cb.value);
                    }
                }
            });
        }
        
        // Clear all sections for a lecture
        function clearAllSections(lectureCode) {
            const sections = [...new Set(allLectures.filter(l => l.Code === lectureCode).map(l => l.Section))];
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            
            checkboxes.forEach(cb => {
                if (sections.includes(cb.value)) {
                    cb.checked = false;
                }
            });
            delete sectionPreferences[lectureCode];
        }
        
        // Clear all filters for a lecture
        function clearAllFilters(lectureCode) {
            delete lecturerPreferences[lectureCode];
            delete sectionPreferences[lectureCode];
            
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
        }
        
        // Apply filters and close popup
        function applyFiltersAndClose(lectureCode) {
            closeLectureFilterPopup();
            updateSelectedLecturesDisplay();
            generateTimetableCombinations();
        }
        
        // Update selected lectures display
        function updateSelectedLecturesDisplay() {
            const container = document.getElementById('selectedLectures');
            
            if (selectedLectures.length === 0) {
                container.innerHTML = '<p style="color: #666; margin: 0;">No lectures selected yet.</p>';
                return;
            }
            
            container.innerHTML = selectedLectures.map(lecture => {
                // Get all available lecturers for this lecture code
                const availableLecturers = [...new Set(
                    allLectures
                        .filter(l => l.Code === lecture.Code)
                        .map(l => l.Lecturer)
                        .filter(l => l && l.trim() !== '')
                )];
                
                // Get all available sections for this lecture code
                const availableSections = [...new Set(
                    allLectures
                        .filter(l => l.Code === lecture.Code)
                        .map(l => l.Section)
                )];
                
                const currentLecturerPref = lecturerPreferences[lecture.Code];
                const currentSectionPref = sectionPreferences[lecture.Code];
                
                // Get the assigned color for this lecture
                const lectureColor = getLectureColor(lecture.Code);
                
                // Create filter summary
                let filterSummary = [];
                if (currentLecturerPref && currentLecturerPref.length > 0) {
                    filterSummary.push(`Lecturers: ${currentLecturerPref.join(', ')}`);
                }
                if (currentSectionPref && currentSectionPref.length > 0) {
                    filterSummary.push(`Sections: ${currentSectionPref.join(', ')}`);
                }
                
                return `
                <div class="selected-lecture-tag" style="display: flex; flex-direction: column; gap: 8px; padding: 12px; margin: 8px 0; background: ${lectureColor.bg}; color: ${lectureColor.text}; border-radius: 8px; border: 1px solid rgba(255,255,255,0.3); cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.15);" 
                     onclick="openLectureFilterPopup('${lecture.Code}')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.25)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)';">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: bold;">${lecture.Code} - ${lecture.Name}</span>
                        <button onclick="event.stopPropagation(); toggleLectureSelection('${lecture.Code}')" class="remove-btn" 
                                style="background: rgba(255,255,255,0.2); color: ${lectureColor.text}; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-weight: bold;">×</button>
                    </div>
                    ${filterSummary.length > 0 ? `
                    <div style="font-size: 11px; color: ${lectureColor.text}; background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);">
                        📦 Filtered: ${filterSummary.join(' | ')}
                    </div>
                    ` : `
                    <div style="font-size: 11px; color: ${lectureColor.text}; opacity: 0.9;">
                        Click to filter sections/lecturers • ${availableSections.length} sections • ${availableLecturers.length} lecturers
                    </div>
                    `}
                </div>
                `;
            }).join('');
        }
        
        // Generate all possible timetable combinations
        function generateTimetableCombinations() {
            const combinationsContainer = document.getElementById('timetableCombinations');
            const container = document.getElementById('combinationsContainer');
            const timetableControls = document.getElementById('timetableControls');
            
            if (selectedLectures.length === 0) {
                combinationsContainer.style.display = 'none';
                timetableControls.style.display = 'none';
                validCombinations = [];
                clearTimetable();
                return;
            }
            
            combinationsContainer.style.display = 'block';
            
            // Get all sections for each selected lecture, filtered by lecturer and section preferences
            const lectureOptions = selectedLectures.map(selected => {
                // Get all sections for this lecture code
                const sectionsForCode = {};
                allLectures.forEach(lecture => {
                    if (lecture.Code === selected.Code) {
                        // Check lecturer preference filter
                        const preferredLecturers = lecturerPreferences[selected.Code];
                        if (preferredLecturers && preferredLecturers.length > 0) {
                            if (!preferredLecturers.includes(lecture.Lecturer)) {
                                return; // Skip this lecture if lecturer not in preferred list
                            }
                        }
                        
                        // Check section preference filter
                        const preferredSections = sectionPreferences[selected.Code];
                        if (preferredSections && preferredSections.length > 0) {
                            if (!preferredSections.includes(lecture.Section)) {
                                return; // Skip this lecture if section not in preferred list
                            }
                        }
                        
                        const sectionKey = lecture.Section;
                        if (!sectionsForCode[sectionKey]) {
                            sectionsForCode[sectionKey] = [];
                        }
                        sectionsForCode[sectionKey].push(lecture);
                    }
                });
                
                const sectionsArray = Object.values(sectionsForCode);
                
                // Check if preferences resulted in no available sections
                if (sectionsArray.length === 0) {
                    const lecturerFilter = lecturerPreferences[selected.Code] ? lecturerPreferences[selected.Code].join(', ') : 'any';
                    const sectionFilter = sectionPreferences[selected.Code] ? sectionPreferences[selected.Code].join(', ') : 'any';
                    console.warn(`No sections available for ${selected.Code} with filters - Lecturers: ${lecturerFilter}, Sections: ${sectionFilter}`);
                }
                
                // Return array of section groups (each section contains all its time slots)
                return sectionsArray;
            }).filter(sections => sections.length > 0); // Filter out empty lecture options
            
            // Check if any lectures have no available sections due to preferences
            if (lectureOptions.length < selectedLectures.length) {
                const missingLectures = selectedLectures.filter((selected, index) => {
                    const sectionsForCode = {};
                    allLectures.forEach(lecture => {
                        if (lecture.Code === selected.Code) {
                            const preferredLecturers = lecturerPreferences[selected.Code];
                            const preferredSections = sectionPreferences[selected.Code];
                            
                            let includeThis = true;
                            
                            if (preferredLecturers && preferredLecturers.length > 0) {
                                includeThis = includeThis && preferredLecturers.includes(lecture.Lecturer);
                            }
                            
                            if (preferredSections && preferredSections.length > 0) {
                                includeThis = includeThis && preferredSections.includes(lecture.Section);
                            }
                            
                            if (includeThis) {
                                sectionsForCode[lecture.Section] = true;
                            }
                        }
                    });
                    return Object.keys(sectionsForCode).length === 0;
                });
                
                if (missingLectures.length > 0) {
                    const filterDetails = missingLectures.map(l => {
                        const lecturerFilter = lecturerPreferences[l.Code] ? lecturerPreferences[l.Code].join(', ') : 'any';
                        const sectionFilter = sectionPreferences[l.Code] ? sectionPreferences[l.Code].join(', ') : 'any';
                        return `<strong>${l.Code}</strong> (Lecturers: ${lecturerFilter}, Sections: ${sectionFilter})`;
                    }).join('<br>');
                    
                    container.innerHTML = `<p style="color: #dc3545; text-align: center; padding: 20px;">No sections available for the selected filters.<br>
                        <small>The following lectures have no sections matching your preferences:<br>
                        ${filterDetails}<br>
                        Click on the lectures above to adjust your filters.</small></p>`;
                    timetableControls.style.display = 'none';
                    clearTimetable();
                    return;
                }
            }
            
            // Generate all combinations
            const combinations = generateCombinations(lectureOptions);
            
            // Filter out combinations with time conflicts
            validCombinations = combinations.filter(combination => !hasTimeConflict(combination));
            
            if (validCombinations.length === 0) {
                const totalCombinations = combinations.length;
                container.innerHTML = `<p style="color: #dc3545; text-align: center; padding: 20px;">No valid combinations found with current conflict settings.<br>
                    <small>Found ${totalCombinations} total combinations, but all exceed ${maxAllowedConflicts} allowed conflict hours.<br>
                    Try increasing the maximum allowed conflicts above.</small></p>`;
                timetableControls.style.display = 'none';
                clearTimetable();
                return;
            }
            
            // Show timetable controls
            timetableControls.style.display = 'block';
            populateCombinationSelector();
            
            // Display combinations list with conflict information
            container.innerHTML = validCombinations.map((combination, index) => {
                const conflictCount = countTimeConflicts(combination);
                const conflictBadge = conflictCount > 0 ? 
                    `<span style="background: #ffc107; color: #856404; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 10px;">${conflictCount} conflict${conflictCount > 1 ? 's' : ''}</span>` : 
                    '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 10px;">No conflicts</span>';
                
                return `
                <div style="margin-bottom: 20px; padding: 15px; border: 2px solid #e0e0e0; border-radius: 10px; background: white;">
                    <h4 style="margin: 0 0 15px 0; color: #007bff; display: flex; align-items: center;">Combination ${index + 1}${conflictBadge}</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
                        ${combination.map(lectureGroup => {
                            const firstLecture = lectureGroup[0];
                            return `
                                <div style="padding: 10px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #28a745;">
                                    <div style="font-weight: bold; color: #007bff;">${firstLecture.Code} - Section ${firstLecture.Section}</div>
                                    <div style="color: #666; font-size: 14px;">${firstLecture.Name}</div>
                                    <div style="color: #333; margin-top: 5px;">${firstLecture.Lecturer}</div>
                                    <div style="color: #666; font-size: 12px; margin-top: 3px;">Excel: ${firstLecture.ExcelTime}</div>
                                    ${lectureGroup.map(lecture => 
                                        `<div style="color: #28a745; font-weight: bold; margin-top: 3px; font-size: 12px;">${lecture.Day} ${lecture.StartHour}:00-${lecture.EndHour}:00</div>`
                                    ).join('')}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <button onclick="selectCombinationInDropdown(${index})" style="margin-top: 15px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Show in Timetable
                    </button>
                </div>
                `;
            }).join('');
            
            // Auto-select first combination if available
            if (validCombinations.length > 0) {
                currentCombinationIndex = 0;
                displayCombinationInTimetable();
            }
        }
        
        // Populate the combination selector dropdown
        function populateCombinationSelector() {
            const selector = document.getElementById('combinationSelector');
            const info = document.getElementById('combinationInfo');
            
            selector.innerHTML = '<option value="">Select a combination...</option>' +
                validCombinations.map((combination, index) => 
                    `<option value="${index}">Combination ${index + 1} (${combination.length} lectures)</option>`
                ).join('');
            
            info.textContent = `${validCombinations.length} valid combination(s) found`;
        }
        
        // Select combination from dropdown
        function selectCombinationInDropdown(index) {
            const selector = document.getElementById('combinationSelector');
            selector.value = index;
            currentCombinationIndex = index;
            displayCombinationInTimetable();
        }
        
        // Display selected combination in timetable
        function displayCombinationInTimetable() {
            const selector = document.getElementById('combinationSelector');
            const selectedIndex = parseInt(selector.value);
            
            if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= validCombinations.length) {
                clearTimetable();
                return;
            }
            
            currentCombinationIndex = selectedIndex;
            clearTimetable();
            
            const combination = validCombinations[selectedIndex];
            console.log('Displaying combination:', selectedIndex + 1, combination);
            
            combination.forEach(lectureGroup => {
                console.log('Placing lecture group:', lectureGroup);
                lectureGroup.forEach(lecture => {
                    placeLectureInTimetable(lecture);
                });
            });
        }
        
        // Toggle time slot lock
        function toggleTimeSlotLock(day, hour) {
            const cellId = `cell_${day}_${hour}`;
            const cell = document.getElementById(cellId);
            const slotKey = `${day}_${hour}`;
            
            if (!cell) return;
            
            // Don't allow locking if cell has a lecture
            if (cell.innerHTML.trim() !== '' && !cell.classList.contains('locked')) {
                return;
            }
            
            if (lockedTimeSlots.has(slotKey)) {
                // Unlock the slot
                lockedTimeSlots.delete(slotKey);
                cell.classList.remove('locked');
                cell.innerHTML = '';
            } else {
                // Lock the slot
                lockedTimeSlots.add(slotKey);
                cell.classList.add('locked');
                cell.innerHTML = '<div class="locked-indicator">🔒</div>';
            }
            
            updateLockedSlotsDisplay();
            
            // Regenerate combinations if there are selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Update locked slots display
        function updateLockedSlotsDisplay() {
            const container = document.getElementById('lockedSlotsContainer');
            const slotsDiv = document.getElementById('lockedSlots');
            
            if (lockedTimeSlots.size === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            
            const lockedSlotsList = Array.from(lockedTimeSlots).map(slotKey => {
                const [day, hour] = slotKey.split('_');
                const nextHour = parseInt(hour) + 1;
                return `<span style="display: inline-block; margin: 2px; padding: 4px 8px; background: #fed7d7; color: #e53e3e; border-radius: 12px; font-size: 12px; border: 1px solid #e53e3e;">
                    ${day} ${hour}:00-${nextHour}:00 🔒
                </span>`;
            }).join('');
            
            slotsDiv.innerHTML = lockedSlotsList;
        }
        
        // Clear all locked slots
        function clearAllLockedSlots() {
            lockedTimeSlots.clear();
            
            // Remove visual indicators
            timeHours.forEach(hour => {
                days.forEach(day => {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    if (cell && cell.classList.contains('locked')) {
                        cell.classList.remove('locked');
                        if (cell.innerHTML.includes('locked-indicator')) {
                            cell.innerHTML = '';
                        }
                    }
                });
            });
            
            updateLockedSlotsDisplay();
            
            // Regenerate combinations if there are selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Clear the timetable - CSS Grid version
        function clearTimetable() {
            timeHours.forEach(hour => {
                days.forEach(day => {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    const slotKey = `${day}_${hour}`;
                    
                    if (cell) {
                        if (lockedTimeSlots.has(slotKey)) {
                            // Keep locked slots
                            cell.className = 'timetable-cell locked';
                            cell.innerHTML = '<div class="locked-indicator">🔒</div>';
                        } else {
                            // Clear unlocked slots
                            cell.innerHTML = '';
                            cell.className = 'timetable-cell';
                        }
                    }
                });
            });
            console.log('Modern timetable cleared, locked slots preserved');
        }
        
        // Place a lecture in the correct timetable cells - spanning multiple rows
        function placeLectureInTimetable(lecture) {
            console.log('=== Placing lecture ===');
            console.log('Lecture object:', lecture);
            
            if (!lecture || !lecture.Day || (!lecture.StartHour && lecture.StartHour !== 0)) {
                console.error('Invalid lecture data:', lecture);
                return;
            }
            
            const day = lecture.Day;
            const startHour = lecture.StartHour;
            const endHour = lecture.EndHour;
            const duration = endHour - startHour;
            
            // Get the assigned color for this lecture
            const lectureColor = getLectureColor(lecture.Code);
            
            console.log(`Placing ${lecture.Code} on ${day} from ${startHour}:00 to ${endHour}:00 (${duration} hours)`);
            
            // Clear all cells that this lecture will span
            for (let hour = startHour; hour < endHour; hour++) {
                const cellId = `cell_${day}_${hour}`;
                const cell = document.getElementById(cellId);
                if (cell) {
                    cell.innerHTML = '';
                    cell.className = 'timetable-cell';
                    cell.style.pointerEvents = '';
                    cell.classList.remove('occupied-continuation');
                }
            }
            
            // Place the lecture block only in the first cell, but make it span multiple rows
            const firstCellId = `cell_${day}_${startHour}`;
            const firstCell = document.getElementById(firstCellId);
            
            if (firstCell) {
                // Calculate the height needed based on actual cell dimensions
                // Each cell: min-height 58px + 2px border (1px top + 1px bottom) = 60px total
                const cellHeight = 60; // 58px min-height + 2px border
                const blockHeight = (duration * cellHeight) - 4; // -4 for internal padding
                
                firstCell.innerHTML = `
                    <div class="lecture-block multi-row" style="height: ${blockHeight}px; background: ${lectureColor.bg}; color: ${lectureColor.text}; box-shadow: 0 4px 12px rgba(0,0,0,0.25);">
                        <div class="lecture-code" style="font-size: ${duration >= 3 ? '14px' : '12px'}; font-weight: bold; margin-bottom: 4px;">${lecture.Code}</div>
                        <div class="lecture-section" style="font-size: ${duration >= 3 ? '12px' : '10px'}; opacity: 0.9; margin-bottom: 4px;">Sec ${lecture.Section}</div>
                        <div class="lecture-lecturer" style="font-size: ${duration >= 3 ? '11px' : '9px'}; opacity: 0.8; line-height: 1.3;">${lecture.Lecturer || 'TBA'}</div>
                        <div style="font-size: ${duration >= 3 ? '10px' : '8px'}; opacity: 0.7; margin-top: 4px;">${startHour}:00-${endHour}:00</div>
                    </div>
                `;
                
                // Mark subsequent cells as occupied (but empty) to prevent clicking
                for (let hour = startHour + 1; hour < endHour; hour++) {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    if (cell) {
                        cell.style.pointerEvents = 'none'; // Prevent clicking on continuation cells
                        cell.classList.add('occupied-continuation');
                    }
                }
            } else {
                console.error(`Cell not found: ${firstCellId}`);
            }
            
            console.log(`Lecture ${lecture.Code} placed successfully as ${duration}-hour spanning block`);
        }
        
        // Generate all possible combinations from arrays
        function generateCombinations(arrays) {
            if (arrays.length === 0) return [[]];
            if (arrays.length === 1) return arrays[0].map(item => [item]);
            
            const result = [];
            const restCombinations = generateCombinations(arrays.slice(1));
            
            for (const item of arrays[0]) {
                for (const combination of restCombinations) {
                    result.push([item, ...combination]);
                }
            }
            
            return result;
        }
        
        // Check if a combination has time conflicts - updated for multiple time slots and locked slots
        // Global variable to store maximum allowed conflicts
        let maxAllowedConflicts = 0;
        
        function countTimeConflicts(combination) {
            // Get all time slots for all lectures in the combination
            const allTimeSlots = [];
            
            combination.forEach(lectureGroup => {
                // lectureGroup contains all time slots for a selected lecture section
                const lectureCode = lectureGroup[0].Code;
                const lectureSection = lectureGroup[0].Section;
                
                lectureGroup.forEach(lecture => {
                    allTimeSlots.push({
                        Code: lectureCode,
                        Section: lectureSection,
                        Day: lecture.Day,
                        StartHour: lecture.StartHour,
                        EndHour: lecture.EndHour
                    });
                });
            });
            
            let conflictHours = 0;
            
            // Check for conflicts with locked time slots
            for (const timeSlot of allTimeSlots) {
                for (let hour = timeSlot.StartHour; hour < timeSlot.EndHour; hour++) {
                    const slotKey = `${timeSlot.Day}_${hour}`;
                    if (lockedTimeSlots.has(slotKey)) {
                        console.log('Conflict with locked slot:', slotKey, 'for lecture:', timeSlot.Code);
                        conflictHours++;
                    }
                }
            }
            
            // Check for conflicts between all time slots
            for (let i = 0; i < allTimeSlots.length; i++) {
                for (let j = i + 1; j < allTimeSlots.length; j++) {
                    const slot1 = allTimeSlots[i];
                    const slot2 = allTimeSlots[j];
                    
                    // Skip if same lecture
                    if (slot1.Code === slot2.Code && slot1.Section === slot2.Section) {
                        continue;
                    }
                    
                    // Check if they're on the same day
                    if (slot1.Day === slot2.Day) {
                        // Calculate overlapping hours
                        const overlapStart = Math.max(slot1.StartHour, slot2.StartHour);
                        const overlapEnd = Math.min(slot1.EndHour, slot2.EndHour);
                        
                        if (overlapStart < overlapEnd) {
                            const overlapHours = overlapEnd - overlapStart;
                            conflictHours += overlapHours;
                            console.log(`Time conflict detected: ${overlapHours} hours between`, 
                                `${slot1.Code}-${slot1.Section} vs ${slot2.Code}-${slot2.Section} on ${slot1.Day}`);
                        }
                    }
                }
            }
            
            return conflictHours;
        }
        
        function hasTimeConflict(combination) {
            const conflicts = countTimeConflicts(combination);
            return conflicts > maxAllowedConflicts;
        }
        
        // Check if two time ranges overlap
        function timeRangesOverlap(range1, range2) {
            return range1.start < range2.end && range2.start < range1.end;
        }
        
        // Update conflict settings when slider changes
        function updateConflictSettings() {
            const slider = document.getElementById('maxConflicts');
            const valueDisplay = document.getElementById('conflictValue');
            
            maxAllowedConflicts = parseInt(slider.value);
            valueDisplay.textContent = maxAllowedConflicts;
            
            console.log('Maximum allowed conflicts set to:', maxAllowedConflicts);
            
            // Regenerate combinations if lectures are already selected
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }

        // Toggle Selected Lectures visibility
        function toggleSelectedLecturesVisibility() {
            const lecturesDiv = document.getElementById('selectedLectures');
            const button = document.getElementById('minimizeSelectedButton');
            const isMinimized = lecturesDiv.style.display === 'none';
            
            if (isMinimized) {
                // Expand
                lecturesDiv.style.display = 'block';
                button.innerHTML = '▲';
                button.title = 'Minimize Selected Lectures';
            } else {
                // Minimize
                lecturesDiv.style.display = 'none';
                button.innerHTML = '▼';
                button.title = 'Show Selected Lectures';
            }
        }
        </script>
</body>
</html>