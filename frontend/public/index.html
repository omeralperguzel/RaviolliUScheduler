<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <h2></h2>
    <title>University Schedule Creator</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            padding: 2rem;
            max-height: 100vh;
            overflow: hidden;
        }
        
        .left-column {
            flex: 0.7;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }
        
        .right-column {
            flex: 1.3;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }
        
        .page-title {
            text-align: center;
            margin: 0 0 2rem 0;
            font-size: 28px;
            color: #333;
            font-weight: bold;
        }
        
        .search-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .search-container h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            border-color: #007bff;
            outline: none;
        }
        
        .lecture-list {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }
        
        .lecture-item {
            margin: 8px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            transition: all 0.2s;
        }
        
        .lecture-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0,123,255,0.15);
        }
        
        .selected-lectures-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .selected-lectures-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .combinations-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .combinations-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .selected-lecture-tag {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-radius: 20px;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }
        
        .remove-btn {
            margin-left: 8px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        
        .remove-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .timetable {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .timetable-section {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .timetable-section h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 22px;
            text-align: center;
        }
        
        .timetable-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin: 0;
            flex: 1;
        }
        
        .timetable-grid {
            display: grid;
            grid-template-columns: 120px repeat(5, 1fr);
            grid-template-rows: 60px repeat(11, 60px);
            gap: 1px;
            background-color: #e2e8f0;
            font-family: 'Arial', sans-serif;
        }
        
        .timetable-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            padding: 10px;
        }
        
        .time-slot {
            background: #f8fafc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #4a5568;
            font-size: 14px;
            border-right: 2px solid #e2e8f0;
        }
        
        .timetable-cell {
            background: #ffffff;
            position: relative;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
            min-height: 58px;
            cursor: pointer;
        }
        
        .timetable-cell:hover {
            background: #f7fafc;
            transform: scale(1.02);
            z-index: 1;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .timetable-cell.locked {
            background: #fed7d7 !important;
            border: 2px solid #e53e3e !important;
            cursor: pointer;
        }
        
        .timetable-cell.locked:hover {
            background: #feb2b2 !important;
            transform: scale(1.02);
        }
        
        .locked-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #e53e3e;
            pointer-events: none;
        }
        
        .lecture-block {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border-radius: 8px;
            padding: 8px;
            color: white;
            font-size: 11px;
            line-height: 1.2;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        .lecture-block:hover {
            transform: scale(1.02);
            z-index: 20;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .lecture-block.multi-row {
            position: absolute;
            border-radius: 8px;
            padding: 12px 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        
        .occupied-continuation {
            background-color: transparent !important;
            border: none !important;
            position: relative;
            z-index: 5;
        }
        
        .lecture-code {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 2px;
        }
        
        .lecture-section {
            font-size: 10px;
            opacity: 0.9;
            margin-bottom: 2px;
        }
        
        .lecture-lecturer {
            font-size: 9px;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .lecture-continuation {
            background: linear-gradient(135deg, #4299e1, #3182ce) !important;
            justify-content: center;
            align-items: center;
        }
        
        .lecture-colors {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        
        .lecture-colors-alt {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }
        
        .lecture-colors-alt2 {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }
        
        .lecture-colors-alt3 {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
        }
        
        .lecture-colors-alt4 {
            background: linear-gradient(135deg, #fa709a, #fee140);
        }
        
        .conflict-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.95);
            color: white;
            padding: 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.4);
            z-index: 15;
            border: 2px solid #dc3545;
        }
        
        .lecture-block.conflicted {
            width: 45% !important;
            z-index: 12;
            border: 2px solid #dc3545;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.4);
        }
        
        .lecture-block.conflicted:first-child {
            left: 2px;
        }
        
        .lecture-block.conflicted:last-child {
            right: 2px;
            left: auto;
        }
        
                .conflict-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.95);
            color: white;
            padding: 4px 6px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.4);
            z-index: 20;
            border: 2px solid #dc3545;
            backdrop-filter: blur(2px);
        }
        
        .lecture-block.conflicted {
            width: 48% !important;
            z-index: 12;
            border: 2px solid #dc3545 !important;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.4) !important;
        }
        
        .lecture-block.conflicted.first {
            left: 1% !important;
        }
        
        .lecture-block.conflicted.second {
            right: 1% !important;
            left: auto !important;
        }
        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                max-height: none;
                overflow: visible;
            }
            
            .left-column,
            .right-column {
                max-height: none;
                overflow-y: visible;
            }
            
            .timetable-grid {
                grid-template-columns: 80px repeat(5, 1fr);
                grid-template-rows: 50px repeat(11, 50px);
                font-size: 12px;
            }
            
            .timetable-header {
                font-size: 14px;
                padding: 8px;
            }
            
            .time-slot {
                font-size: 12px;
            }
            
            .lecture-block {
                padding: 4px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
        <div id="root"></div>
        <h1 class="page-title">University Schedule Creator</h1>
        
        <div class="main-container">
            <!-- Left Column -->
            <div class="left-column">
                <!-- Search and Lecture Selection Section -->
                <div class="search-container">
                    <h2>Search and Select Lectures</h2>
                    <div style="margin-bottom: 1rem;">
                        <input type="text" id="lectureSearch" placeholder="Search for lectures, codes, or lecturers..." 
                               class="search-input">
                    </div>
                    
                    <div id="lectureList" class="lecture-list" style="padding: 10px;">
                        <div id="loadingMessage" style="text-align: center; color: #666;">Loading lectures...</div>
                        <div id="lectureResults"></div>
                    </div>
                </div>
                
                <!-- Conflict Settings Section -->
                <div class="conflict-settings-container" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px; border: 1px solid #e9ecef;">
                    <h3 style="margin: 0 0 15px 0; color: #495057;">Conflict Settings</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label for="maxConflicts" style="font-weight: 500; color: #495057;">Maximum Conflicting Hours Allowed:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="range" id="maxConflicts" min="0" max="10" value="0" 
                                   style="flex: 1;" onchange="updateConflictSettings()">
                            <span id="conflictValue" style="font-weight: bold; color: #007bff; min-width: 30px;">0</span>
                        </div>
                        <small style="color: #6c757d;">Set to 0 for no conflicts (default), increase to allow overlapping lectures</small>
                    </div>
                </div>
                
                <!-- Possible Timetable Combinations -->
                <div id="timetableCombinations" class="combinations-container" style="display: none;">
                    <h3>Possible Timetable Combinations:</h3>
                    <div id="combinationsContainer" style="flex: 1; overflow-y: auto;">
                    </div>
                </div>
            </div>
            
            <!-- Right Column -->
            <div class="right-column">
                <!-- Selected Lectures -->
                <div class="selected-lectures-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Selected Lectures:</h3>
                        <button id="minimizeSelectedButton" onclick="toggleSelectedLecturesVisibility()" 
                                style="background: #6c757d; color: white; border: none; border-radius: 6px; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: all 0.2s ease;"
                                onmouseover="this.style.background='#5a6268'" onmouseout="this.style.background='#6c757d'">
                            ▲
                        </button>
                    </div>
                    <div id="selectedLectures" style="min-height: 50px;">
                        <p style="color: #666; margin: 0;">No lectures selected yet.</p>
                    </div>
                </div>
                
                <!-- Locked Time Slots -->
                <div id="lockedSlotsContainer" class="selected-lectures-container" style="display: none;">
                    <h3>Locked Time Slots:</h3>
                    <div id="lockedSlots" style="min-height: 30px;">
                        <p style="color: #666; margin: 0; font-size: 14px;">Click on empty timetable cells to lock them.</p>
                    </div>
                    <button onclick="clearAllLockedSlots()" style="margin-top: 10px; padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Clear All Locked Slots
                    </button>
                </div>
                
                <!-- Timetable Controls -->
                <div id="timetableControls" style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: none;">
                    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                        <div>
                            <label style="font-weight: bold; margin-right: 10px;">Timetable Combination:</label>
                            <select id="combinationSelector" onchange="displayCombinationInTimetable()" style="padding: 8px; border: 2px solid #e0e0e0; border-radius: 5px; background: white;">
                                <option value="">Select a combination...</option>
                            </select>
                        </div>
                        <div style="color: #666; font-size: 14px;">
                            <span id="combinationInfo"></span>
                        </div>
                    </div>
                </div>
                
                <!-- Weekly Timetable -->
                <div class="timetable-section">
                    <h2>Weekly Timetable</h2>
                    
                    <div class="timetable-container">
                        <div class="timetable-grid" id="timetableGrid">
                            <!-- Timetable will be generated dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <script>
        // Lecture data and functionality
        let allLectures = [];
        let selectedLectures = [];
        let validCombinations = [];
        let currentCombinationIndex = 0;
        let lockedTimeSlots = new Set(); // Format: "Day_Hour" (e.g., "Monday_10")
        let lecturerPreferences = {}; // Object to store preferred lecturers for each lecture code
        let sectionPreferences = {}; // Object to store preferred sections for each lecture code
        let lectureColors = {}; // Object to store assigned colors for each lecture code
        
        // Alternative course management
        let alternativeCourseGroups = {}; // Object to store alternative course groups: {groupId: [courseCode1, courseCode2]}
        let courseToAlternativeGroup = {}; // Object to map course codes to their alternative group ID
        let alternativeGroupCounter = 0; // Counter to generate unique group IDs
        
        // Simple time structure - each hour from 9 to 19
        const timeHours = [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
        const days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        const dayColumnMap = {
            "Monday": 1,
            "Tuesday": 2, 
            "Wednesday": 3,
            "Thursday": 4,
            "Friday": 5
        };
        
        // Process lectures to parse time slots from Excel format
        function processLectures(rawLectures) {
            const processedLectures = [];
            
            rawLectures.forEach(lecture => {
                const timeSlots = parseExcelTime(lecture.ExcelTime);
                
                if (timeSlots.length === 0) {
                    console.warn('No valid time slots found for lecture:', lecture);
                    return;
                }
                
                // Create a lecture entry for each time slot
                timeSlots.forEach((timeSlot, index) => {
                    processedLectures.push({
                        ...lecture,
                        Day: timeSlot.Day,
                        StartHour: timeSlot.StartHour,
                        EndHour: timeSlot.EndHour,
                        TimeSlotIndex: index // To track multiple slots for same lecture
                    });
                });
            });
            
            return processedLectures;
        }
        
        // Color generation and assignment functions
        function generateRandomColor() {
            const colors = [
                { bg: 'linear-gradient(135deg, #667eea, #764ba2)', text: 'white' },
                { bg: 'linear-gradient(135deg, #f093fb, #f5576c)', text: 'white' },
                { bg: 'linear-gradient(135deg, #4facfe, #00f2fe)', text: 'white' },
                { bg: 'linear-gradient(135deg, #43e97b, #38f9d7)', text: 'white' },
                { bg: 'linear-gradient(135deg, #fa709a, #fee140)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ff9a9e, #fecfef)', text: 'white' },
                { bg: 'linear-gradient(135deg, #a18cd1, #fbc2eb)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffecd2, #fcb69f)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ff8a80, #ff5722)', text: 'white' },
                { bg: 'linear-gradient(135deg, #81c784, #4caf50)', text: 'white' },
                { bg: 'linear-gradient(135deg, #64b5f6, #2196f3)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ba68c8, #9c27b0)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffb74d, #ff9800)', text: 'white' },
                { bg: 'linear-gradient(135deg, #4db6ac, #009688)', text: 'white' },
                { bg: 'linear-gradient(135deg, #f06292, #e91e63)', text: 'white' },
                { bg: 'linear-gradient(135deg, #aed581, #8bc34a)', text: 'white' },
                { bg: 'linear-gradient(135deg, #90a4ae, #607d8b)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffcc02, #ffc107)', text: 'white' },
                { bg: 'linear-gradient(135deg, #26c6da, #00bcd4)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ab47bc, #8e24aa)', text: 'white' }
            ];
            
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function assignLectureColor(lectureCode) {
            if (!lectureColors[lectureCode]) {
                lectureColors[lectureCode] = generateRandomColor();
                console.log(`Assigned color to ${lectureCode}:`, lectureColors[lectureCode]);
            }
            return lectureColors[lectureCode];
        }
        
        function getLectureColor(lectureCode) {
            return lectureColors[lectureCode] || { bg: 'linear-gradient(135deg, #667eea, #764ba2)', text: 'white' };
        }
        
        // Day name mapping
        const dayMapping = {
            'Mo': 'Monday',
            'Tu': 'Tuesday', 
            'We': 'Wednesday',
            'Th': 'Thursday',
            'Fr': 'Friday'
        };
        
        // Parse Excel time format like "Fr 13 - 16" or "Tu/Fr 09 - 12 Tu/Fr 13 - 15"
        function parseExcelTime(timeString) {
            if (!timeString) return [];
            
            const timeSlots = [];
            
            // Handle complex patterns like "Tu/Fr 09 - 12 Tu/Fr 13 - 15"
            // First, split by multiple consecutive spaces to separate different time blocks
            let timeBlocks = timeString.split(/\s{2,}/).filter(block => block.trim());
            
            // If no multiple spaces found, treat as single block
            if (timeBlocks.length <= 1) {
                timeBlocks = [timeString];
            }
            
            timeBlocks.forEach(block => {
                // Handle patterns like "Tu/Fr 09 - 12" (multiple days with same time)
                const dayTimeMatch = block.match(/([A-Za-z]{2}(?:\/[A-Za-z]{2})*)\s+(\d{1,2})\s*-\s*(\d{1,2})/);
                
                if (dayTimeMatch) {
                    const [, dayPart, startHour, endHour] = dayTimeMatch;
                    const days = dayPart.split('/'); // Split multiple days like "Tu/Fr"
                    
                    days.forEach(dayAbbr => {
                        const fullDay = dayMapping[dayAbbr.trim()];
                        if (fullDay) {
                            timeSlots.push({
                                Day: fullDay,
                                StartHour: parseInt(startHour),
                                EndHour: parseInt(endHour)
                            });
                        }
                    });
                } else {
                    // Handle simple patterns like "Mo 11 - 13" or multiple separate day-time pairs
                    const simplePatterns = block.match(/[A-Za-z]{2}\s+\d{1,2}\s*-\s*\d{1,2}/g);
                    
                    if (simplePatterns) {
                        simplePatterns.forEach(pattern => {
                            const match = pattern.match(/([A-Za-z]{2})\s+(\d{1,2})\s*-\s*(\d{1,2})/);
                            if (match) {
                                const [, dayAbbr, startHour, endHour] = match;
                                const fullDay = dayMapping[dayAbbr];
                                if (fullDay) {
                                    timeSlots.push({
                                        Day: fullDay,
                                        StartHour: parseInt(startHour),
                                        EndHour: parseInt(endHour)
                                    });
                                }
                            }
                        });
                    }
                }
            });
            
            return timeSlots;
        }
        
        // Sample lecture data with Excel-like time format (matching real Excel structure)
        const sampleLectures = [
            { Code: "ADA 403", Name: "Exploratory Data Analysis", Lecturer: "", Hours: "3", Section: "01", ExcelTime: "Fr 13 - 16" },
            { Code: "ADA 423", Name: "Statistical Inference Methods with Applications", Lecturer: "Şafak Özden", Hours: "3", Section: "01", ExcelTime: "Th 11 - 14" },
            { Code: "ARCH 101", Name: "Basics of Design", Lecturer: "Gökhan Kınayoğlu", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 13 - 15 Tu/Fr 09 - 12" },
            { Code: "ARCH 111", Name: "Architectural Communication Techniques I", Lecturer: "Başak Uçar Kırmızıgöl", Hours: "3", Section: "01", ExcelTime: "Th 09 - 13" },
            { Code: "ARCH 121", Name: "Introduction to Architecture", Lecturer: "Bilge İmamoğlu", Hours: "3", Section: "01", ExcelTime: "We 09 - 12" },
            { Code: "ARCH 201", Name: "Architectural Design I", Lecturer: "Zuhal Acar Metin", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 09 - 12 Tu/Fr 13 - 15" },
            { Code: "ARCH 301", Name: "Architectural Design III", Lecturer: "Azize Elif Yabacı", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 09 - 12 Tu/Fr 13 - 15" },
            { Code: "ARCH 301-O", Name: "Architectural Design III", Lecturer: "Gültekin Doruk Atay", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 13 - 15 Tu/Fr 09 - 12" },
            { Code: "ARCH 381", Name: "Urban Design", Lecturer: "Seray Türkay Coşkun", Hours: "3", Section: "01", ExcelTime: "Mo 09 - 13" },
            { Code: "BA 305", Name: "Production and Operations Management", Lecturer: "Hakan Bütüner", Hours: "3", Section: "01", ExcelTime: "Mo 12 - 15 Th 17 - 18" },
            { Code: "CE 214", Name: "Introduction to Mechanics of Materials", Lecturer: "Rıza Secer Orkun Keskin", Hours: "4", Section: "01", ExcelTime: "Tu 14 - 16 We 14 - 15 Fr 15 - 17" },
            { Code: "CE 331", Name: "Hydromechanics", Lecturer: "Aslı Numanoğlu Genç", Hours: "4", Section: "01", ExcelTime: "We 15 - 16 Th 12 - 14 Fr 13 - 15" }
        ];
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            initializeTimetable();
            loadLectures();
            setupSearchFunctionality();
        });
        
        // Initialize empty timetable
        function initializeTimetable() {
            const timetableGrid = document.getElementById('timetableGrid');
            
            // Create CSS Grid layout
            let gridHTML = '';
            
            // Headers
            gridHTML += '<div class="timetable-header">Time</div>';
            gridHTML += '<div class="timetable-header">Monday</div>';
            gridHTML += '<div class="timetable-header">Tuesday</div>';
            gridHTML += '<div class="timetable-header">Wednesday</div>';
            gridHTML += '<div class="timetable-header">Thursday</div>';
            gridHTML += '<div class="timetable-header">Friday</div>';
            
            // Time slots and cells
            timeHours.forEach(hour => {
                const nextHour = hour + 1;
                const timeLabel = `${hour.toString().padStart(2, '0')}:00 - ${nextHour.toString().padStart(2, '0')}:00`;
                
                // Time slot
                gridHTML += `<div class="time-slot">${timeLabel}</div>`;
                
                // Day cells with click handlers
                days.forEach(day => {
                    gridHTML += `<div class="timetable-cell" id="cell_${day}_${hour}" onclick="toggleTimeSlotLock('${day}', ${hour})"></div>`;
                });
            });
            
            timetableGrid.innerHTML = gridHTML;
            console.log('Modern timetable initialized with CSS Grid and click handlers');
        }
        
        // Load lectures from API or use sample data
        async function loadLectures() {
            try {
                const response = await fetch('http://localhost:5000/api/lectures');
                if (response.ok) {
                    const rawLectures = await response.json();
                    allLectures = processLectures(rawLectures);
                } else {
                    throw new Error('API not available');
                }
            } catch (error) {
                console.log('Using sample data - API not available');
                allLectures = processLectures(sampleLectures);
            }
            
            console.log('Processed lectures:', allLectures);
            document.getElementById('loadingMessage').style.display = 'none';
            displayLectures(allLectures);
        }
        
        // Setup search functionality
        function setupSearchFunctionality() {
            const searchInput = document.getElementById('lectureSearch');
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase().normalize('NFD');
                const filteredLectures = allLectures.filter(lecture => 
                    lecture.Code.toLowerCase().normalize('NFD').includes(searchTerm) ||
                    lecture.Name.toLowerCase().normalize('NFD').includes(searchTerm) ||
                    (lecture.Lecturer && lecture.Lecturer.toLowerCase().normalize('NFD').includes(searchTerm))
                );
                displayLectures(filteredLectures);
            });
        }
        
        // Display lectures in the list
        function displayLectures(lectures) {
            const resultsContainer = document.getElementById('lectureResults');
            
            if (lectures.length === 0) {
                resultsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No lectures found.</p>';
                return;
            }
            
            // Group lectures by code and name only (merge all sections)
            const lecturesByCode = {};
            lectures.forEach(lecture => {
                const key = lecture.Code; // Group by code only
                if (!lecturesByCode[key]) {
                    lecturesByCode[key] = {
                        Code: lecture.Code,
                        Name: lecture.Name,
                        Hours: lecture.Hours,
                        sections: []
                    };
                }
                
                // Find or create section within this lecture
                let existingSection = lecturesByCode[key].sections.find(s => s.Section === lecture.Section);
                if (!existingSection) {
                    existingSection = {
                        Section: lecture.Section,
                        Lecturer: lecture.Lecturer,
                        ExcelTime: lecture.ExcelTime,
                        timeSlots: []
                    };
                    lecturesByCode[key].sections.push(existingSection);
                }
                
                // Add time slot to section
                existingSection.timeSlots.push({
                    Day: lecture.Day,
                    StartHour: lecture.StartHour,
                    EndHour: lecture.EndHour
                });
            });
            
            resultsContainer.innerHTML = Object.values(lecturesByCode).map(lecture => `
                <div class="lecture-item">
                    <label style="display: flex; align-items: flex-start; cursor: pointer;">
                        <input type="checkbox" value="${lecture.Code}" onchange="toggleLectureSelection('${lecture.Code}')" 
                               style="margin-right: 15px; margin-top: 5px; transform: scale(1.3);"
                               ${selectedLectures.some(selected => selected.Code === lecture.Code) ? 'checked' : ''}>
                        <div style="flex: 1;">
                            <div><strong style="color: #007bff; font-size: 16px;">${lecture.Code}</strong> - ${lecture.Name}</div>
                            <div style="color: #666; margin: 8px 0;">Hours: ${lecture.Hours}</div>
                            <div style="margin-top: 10px;">
                                <strong style="color: #333; font-size: 14px;">Available Sections:</strong>
                                <div style="margin-top: 5px;">
                                    ${lecture.sections.map(section => `
                                        <div style="background: #f8f9fa; padding: 8px; margin: 4px 0; border-radius: 5px; border-left: 3px solid #007bff;">
                                            <span style="font-weight: bold;">Section ${section.Section}</span> - ${section.Lecturer}<br>
                                            <span style="color: #666; font-size: 12px;">Excel Time: ${section.ExcelTime}</span><br>
                                            ${section.timeSlots.map(slot => 
                                                `<span style="color: #28a745; font-weight: bold; display: inline-block; margin-right: 10px;">${slot.Day} ${slot.StartHour}:00-${slot.EndHour}:00</span>`
                                            ).join('')}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    </label>
                </div>
            `).join('');
        }
        
        // Toggle lecture selection
        function toggleLectureSelection(lectureCode) {
            const lecturesWithCode = allLectures.filter(l => l.Code === lectureCode);
            const existingIndex = selectedLectures.findIndex(l => l.Code === lectureCode);
            
            if (existingIndex > -1) {
                selectedLectures.splice(existingIndex, 1);
                // Remove both lecturer and section preferences when lecture is deselected
                delete lecturerPreferences[lectureCode];
                delete sectionPreferences[lectureCode];
                // Remove color assignment when lecture is deselected
                delete lectureColors[lectureCode];
            } else {
                // Add the first occurrence (we'll show all sections in combinations)
                selectedLectures.push(lecturesWithCode[0]);
                // Assign a random color to the newly selected lecture
                assignLectureColor(lectureCode);
            }
            
            updateSelectedLecturesDisplay();
            generateTimetableCombinations();
        }
        
        // Update lecturer preference for a specific lecture
        function updateLecturerPreference(lectureCode, preferredLecturer) {
            console.log(`Updating lecturer preference for ${lectureCode} to ${preferredLecturer}`);
            
            if (preferredLecturer === 'any') {
                delete lecturerPreferences[lectureCode];
            } else {
                lecturerPreferences[lectureCode] = preferredLecturer;
            }
            
            // Regenerate combinations if we have selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Open lecture filter popup
        function openLectureFilterPopup(lectureCode) {
            const lecture = selectedLectures.find(l => l.Code === lectureCode);
            if (!lecture) return;
            
            // Get all sections for this lecture with their details
            const sections = {};
            allLectures.forEach(l => {
                if (l.Code === lectureCode) {
                    if (!sections[l.Section]) {
                        sections[l.Section] = {
                            section: l.Section,
                            lecturer: l.Lecturer || 'TBA',
                            excelTime: l.ExcelTime,
                            timeSlots: []
                        };
                    }
                    sections[l.Section].timeSlots.push({
                        day: l.Day,
                        startHour: l.StartHour,
                        endHour: l.EndHour
                    });
                }
            });
            
            const sectionList = Object.values(sections);
            const allLecturers = [...new Set(sectionList.map(s => s.lecturer).filter(l => l && l !== 'TBA'))];
            
            const currentLecturerPref = lecturerPreferences[lectureCode] || [];
            const currentSectionPref = sectionPreferences[lectureCode] || [];
            
            // Create popup HTML
            const popupHTML = `
                <div id="lectureFilterOverlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center;" onclick="closeLectureFilterPopup()">
                    <div style="background: white; border-radius: 12px; padding: 24px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3);" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0; color: #333;">🎯 Filter: ${lectureCode} - ${lecture.Name}</h3>
                            <button onclick="closeLectureFilterPopup()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">×</button>
                        </div>
                        
                        <!-- Lecturer Filter Section -->
                        <div style="margin-bottom: 24px;">
                            <h4 style="margin: 0 0 12px 0; color: #495057;">Select Lecturers:</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;">
                                ${allLecturers.map(lecturer => `
                                    <label style="display: flex; align-items: center; background: #f8f9fa; padding: 8px 12px; border-radius: 20px; cursor: pointer; transition: all 0.2s; border: 1px solid #dee2e6;" 
                                           onmouseover="this.style.backgroundColor='#e9ecef'" onmouseout="this.style.backgroundColor='#f8f9fa'">
                                        <input type="checkbox" value="${lecturer}" ${currentLecturerPref.includes(lecturer) ? 'checked' : ''} 
                                               onchange="toggleLecturerFilter('${lectureCode}', '${lecturer}', this.checked)" 
                                               style="margin-right: 8px;">
                                        <span style="font-size: 13px;">${lecturer}</span>
                                    </label>
                                `).join('')}
                            </div>
                            <button onclick="selectAllLecturers('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">Select All</button>
                            <button onclick="clearAllLecturers('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear All</button>
                        </div>
                        
                        <!-- Section Filter Section -->
                        <div style="margin-bottom: 24px;">
                            <h4 style="margin: 0 0 12px 0; color: #495057;">Select Sections:</h4>
                            <div style="display: grid; gap: 12px;">
                                ${sectionList.map(section => `
                                    <label style="display: flex; align-items: flex-start; background: #f8f9fa; padding: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid #dee2e6;" 
                                           onmouseover="this.style.backgroundColor='#e9ecef'" onmouseout="this.style.backgroundColor='#f8f9fa'">
                                        <input type="checkbox" value="${section.section}" ${currentSectionPref.includes(section.section) ? 'checked' : ''} 
                                               onchange="toggleSectionFilter('${lectureCode}', '${section.section}', this.checked)" 
                                               style="margin-right: 12px; margin-top: 2px;">
                                        <div style="flex: 1;">
                                            <div style="font-weight: bold; color: #007bff; margin-bottom: 4px;">Section ${section.section}</div>
                                            <div style="font-size: 13px; color: #666; margin-bottom: 4px;">Lecturer: ${section.lecturer}</div>
                                            <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Schedule: ${section.excelTime}</div>
                                            <div style="font-size: 11px; color: #28a745;">
                                                ${section.timeSlots.map(slot => `${slot.day} ${slot.startHour}:00-${slot.endHour}:00`).join(' | ')}
                                            </div>
                                        </div>
                                    </label>
                                `).join('')}
                            </div>
                            <div style="margin-top: 12px;">
                                <button onclick="selectAllSections('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">Select All</button>
                                <button onclick="clearAllSections('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear All</button>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; justify-content: flex-end; gap: 12px; padding-top: 12px; border-top: 1px solid #dee2e6;">
                            <button onclick="clearAllFilters('${lectureCode}')" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;">Clear All Filters</button>
                            <button onclick="applyFiltersAndClose('${lectureCode}')" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">Apply Filters</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add popup to DOM
            document.body.insertAdjacentHTML('beforeend', popupHTML);
        }
        
        // Close lecture filter popup
        function closeLectureFilterPopup() {
            const overlay = document.getElementById('lectureFilterOverlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Toggle lecturer filter
        function toggleLecturerFilter(lectureCode, lecturer, isChecked) {
            if (!lecturerPreferences[lectureCode]) {
                lecturerPreferences[lectureCode] = [];
            }
            
            if (isChecked) {
                if (!lecturerPreferences[lectureCode].includes(lecturer)) {
                    lecturerPreferences[lectureCode].push(lecturer);
                }
            } else {
                lecturerPreferences[lectureCode] = lecturerPreferences[lectureCode].filter(l => l !== lecturer);
                if (lecturerPreferences[lectureCode].length === 0) {
                    delete lecturerPreferences[lectureCode];
                }
            }
        }
        
        // Toggle section filter
        function toggleSectionFilter(lectureCode, section, isChecked) {
            if (!sectionPreferences[lectureCode]) {
                sectionPreferences[lectureCode] = [];
            }
            
            if (isChecked) {
                if (!sectionPreferences[lectureCode].includes(section)) {
                    sectionPreferences[lectureCode].push(section);
                }
            } else {
                sectionPreferences[lectureCode] = sectionPreferences[lectureCode].filter(s => s !== section);
                if (sectionPreferences[lectureCode].length === 0) {
                    delete sectionPreferences[lectureCode];
                }
            }
        }
        
        // Select all lecturers for a lecture
        function selectAllLecturers(lectureCode) {
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            const lecturerCheckboxes = Array.from(checkboxes).filter(cb => {
                return allLectures.some(l => l.Code === lectureCode && l.Lecturer === cb.value);
            });
            
            lecturerPreferences[lectureCode] = [];
            lecturerCheckboxes.forEach(cb => {
                cb.checked = true;
                if (!lecturerPreferences[lectureCode].includes(cb.value)) {
                    lecturerPreferences[lectureCode].push(cb.value);
                }
            });
        }
        
        // Clear all lecturers for a lecture
        function clearAllLecturers(lectureCode) {
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            const lecturerCheckboxes = Array.from(checkboxes).filter(cb => {
                return allLectures.some(l => l.Code === lectureCode && l.Lecturer === cb.value);
            });
            
            lecturerCheckboxes.forEach(cb => cb.checked = false);
            delete lecturerPreferences[lectureCode];
        }
        
        // Select all sections for a lecture
        function selectAllSections(lectureCode) {
            const sections = [...new Set(allLectures.filter(l => l.Code === lectureCode).map(l => l.Section))];
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            
            sectionPreferences[lectureCode] = [];
            checkboxes.forEach(cb => {
                if (sections.includes(cb.value)) {
                    cb.checked = true;
                    if (!sectionPreferences[lectureCode].includes(cb.value)) {
                        sectionPreferences[lectureCode].push(cb.value);
                    }
                }
            });
        }
        
        // Clear all sections for a lecture
        function clearAllSections(lectureCode) {
            const sections = [...new Set(allLectures.filter(l => l.Code === lectureCode).map(l => l.Section))];
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            
            checkboxes.forEach(cb => {
                if (sections.includes(cb.value)) {
                    cb.checked = false;
                }
            });
            delete sectionPreferences[lectureCode];
        }
        
        // Clear all filters for a lecture
        function clearAllFilters(lectureCode) {
            delete lecturerPreferences[lectureCode];
            delete sectionPreferences[lectureCode];
            
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
        }
        
        // Apply filters and close popup
        function applyFiltersAndClose(lectureCode) {
            closeLectureFilterPopup();
            updateSelectedLecturesDisplay();
            generateTimetableCombinations();
        }
        
        // Alternative Course Management Functions
        
        // Create a new alternative course group
        function createAlternativeGroup(courseCode1, courseCode2) {
            const groupId = `alt_group_${alternativeGroupCounter++}`;
            
            // Remove courses from existing groups first
            removeFromAlternativeGroup(courseCode1);
            removeFromAlternativeGroup(courseCode2);
            
            // Create new group
            alternativeCourseGroups[groupId] = [courseCode1, courseCode2];
            courseToAlternativeGroup[courseCode1] = groupId;
            courseToAlternativeGroup[courseCode2] = groupId;
            
            console.log(`Created alternative group ${groupId}:`, [courseCode1, courseCode2]);
            updateSelectedLecturesDisplay();
            generateTimetableCombinations();
        }
        
        // Remove a course from its alternative group
        function removeFromAlternativeGroup(courseCode) {
            const groupId = courseToAlternativeGroup[courseCode];
            if (groupId && alternativeCourseGroups[groupId]) {
                const group = alternativeCourseGroups[groupId];
                const index = group.indexOf(courseCode);
                if (index > -1) {
                    group.splice(index, 1);
                }
                
                // Remove course mapping
                delete courseToAlternativeGroup[courseCode];
                
                // If group has less than 2 courses, dissolve it
                if (group.length < 2) {
                    group.forEach(code => delete courseToAlternativeGroup[code]);
                    delete alternativeCourseGroups[groupId];
                }
                
                console.log(`Removed ${courseCode} from alternative group ${groupId}`);
                updateSelectedLecturesDisplay();
                generateTimetableCombinations();
            }
        }
        
        // Get all courses that can be alternatives to a given course
        function getAvailableAlternatives(courseCode) {
            return selectedLectures
                .filter(lecture => lecture.Code !== courseCode && !courseToAlternativeGroup[lecture.Code])
                .map(lecture => lecture.Code);
        }
        
        // Check if a course is part of an alternative group
        function isInAlternativeGroup(courseCode) {
            return courseToAlternativeGroup[courseCode] !== undefined;
        }
        
        // Get alternative group info for a course
        function getAlternativeGroupInfo(courseCode) {
            const groupId = courseToAlternativeGroup[courseCode];
            if (groupId && alternativeCourseGroups[groupId]) {
                return {
                    groupId,
                    alternatives: alternativeCourseGroups[groupId].filter(code => code !== courseCode)
                };
            }
            return null;
        }
        
        // Update selected lectures display
        function updateSelectedLecturesDisplay() {
            const container = document.getElementById('selectedLectures');
            
            if (selectedLectures.length === 0) {
                container.innerHTML = '<p style="color: #666; margin: 0;">No lectures selected yet.</p>';
                return;
            }
            
            container.innerHTML = selectedLectures.map(lecture => {
                // Get all available lecturers for this lecture code
                const availableLecturers = [...new Set(
                    allLectures
                        .filter(l => l.Code === lecture.Code)
                        .map(l => l.Lecturer)
                        .filter(l => l && l.trim() !== '')
                )];
                
                // Get all available sections for this lecture code
                const availableSections = [...new Set(
                    allLectures
                        .filter(l => l.Code === lecture.Code)
                        .map(l => l.Section)
                )];
                
                const currentLecturerPref = lecturerPreferences[lecture.Code];
                const currentSectionPref = sectionPreferences[lecture.Code];
                
                // Get the assigned color for this lecture
                const lectureColor = getLectureColor(lecture.Code);
                
                // Create filter summary
                let filterSummary = [];
                if (currentLecturerPref && currentLecturerPref.length > 0) {
                    filterSummary.push(`Lecturers: ${currentLecturerPref.join(', ')}`);
                }
                if (currentSectionPref && currentSectionPref.length > 0) {
                    filterSummary.push(`Sections: ${currentSectionPref.join(', ')}`);
                }
                
                // Get alternative course information
                const alternativeInfo = getAlternativeGroupInfo(lecture.Code);
                const availableAlternatives = getAvailableAlternatives(lecture.Code);
                
                return `
                <div class="selected-lecture-tag" style="display: flex; flex-direction: column; gap: 8px; padding: 12px; margin: 8px 0; background: ${lectureColor.bg}; color: ${lectureColor.text}; border-radius: 8px; border: 1px solid rgba(255,255,255,0.3); cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.15);" 
                     onclick="openLectureFilterPopup('${lecture.Code}')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.25)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)';">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: bold;">${lecture.Code} - ${lecture.Name}</span>
                        <div style="display: flex; gap: 4px;">
                            <button onclick="event.stopPropagation(); showAlternativePopup('${lecture.Code}')" 
                                    style="background: rgba(255,255,255,0.2); color: ${lectureColor.text}; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;" 
                                    title="Manage alternative courses">🔄</button>
                            <button onclick="event.stopPropagation(); toggleLectureSelection('${lecture.Code}')" class="remove-btn" 
                                    style="background: rgba(255,255,255,0.2); color: ${lectureColor.text}; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-weight: bold;">×</button>
                        </div>
                    </div>
                    
                    ${alternativeInfo ? `
                    <div style="font-size: 11px; color: ${lectureColor.text}; background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);">
                        🔄 Alternative to: ${alternativeInfo.alternatives.join(', ')}
                    </div>
                    ` : ''}
                    
                    ${filterSummary.length > 0 ? `
                    <div style="font-size: 11px; color: ${lectureColor.text}; background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);">
                        📦 Filtered: ${filterSummary.join(' | ')}
                    </div>
                    ` : `
                    <div style="font-size: 11px; color: ${lectureColor.text}; opacity: 0.9;">
                        Click to filter sections/lecturers • ${availableSections.length} sections • ${availableLecturers.length} lecturers
                    </div>
                    `}
                </div>
                `;
            }).join('');
        }
        
        // Show alternative course popup
        function showAlternativePopup(courseCode) {
            const alternativeInfo = getAlternativeGroupInfo(courseCode);
            const availableAlternatives = getAvailableAlternatives(courseCode);
            
            const popupHTML = `
                <div id="alternativePopupOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                    <div style="background: white; padding: 20px; border-radius: 12px; max-width: 500px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                        <h3 style="margin: 0 0 15px 0; color: #333;">Alternative Courses for ${courseCode}</h3>
                        
                        ${alternativeInfo ? `
                            <div style="background: #e8f5e8; padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #4caf50;">
                                <strong>🔄 Currently paired with:</strong> ${alternativeInfo.alternatives.join(', ')}
                                <div style="margin-top: 8px;">
                                    <button onclick="removeFromAlternativeGroup('${courseCode}'); closeAlternativePopup();" 
                                            style="background: #ff5722; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                        Remove from alternative group
                                    </button>
                                </div>
                            </div>
                        ` : `
                            <div style="background: #fff3e0; padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #ff9800;">
                                <strong>ℹ️ Not in any alternative group</strong>
                                <p style="margin: 5px 0 0 0; font-size: 14px; color: #666;">You can create an alternative group by selecting another course below.</p>
                            </div>
                        `}
                        
                        ${availableAlternatives.length > 0 ? `
                            <div style="margin-bottom: 15px;">
                                <strong>Available alternatives:</strong>
                                <div style="margin-top: 8px; display: flex; flex-direction: column; gap: 6px;">
                                    ${availableAlternatives.map(altCode => `
                                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #f5f5f5; border-radius: 6px;">
                                            <span>${altCode}</span>
                                            <button onclick="createAlternativeGroup('${courseCode}', '${altCode}'); closeAlternativePopup();" 
                                                    style="background: #4caf50; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                                ${alternativeInfo ? 'Switch to this alternative' : 'Create alternative group'}
                                            </button>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : `
                            <div style="background: #ffebee; padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #f44336;">
                                <strong>⚠️ No available alternatives</strong>
                                <p style="margin: 5px 0 0 0; font-size: 14px; color: #666;">All other selected courses are already in alternative groups.</p>
                            </div>
                        `}
                        
                        <div style="text-align: right; margin-top: 15px;">
                            <button onclick="closeAlternativePopup()" style="background: #2196f3; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                                Done
                            </button>
                        </div>
                        
                        <div style="margin-top: 15px; padding: 12px; background: #f0f8ff; border-radius: 6px; border: 1px solid #2196f3;">
                            <strong>💡 How Alternative Courses Work:</strong>
                            <ul style="margin: 5px 0 0 0; padding-left: 15px; font-size: 13px; color: #666;">
                                <li>Only one course from each alternative group will appear in any timetable combination</li>
                                <li>This helps when you need to choose between similar courses</li>
                                <li>Alternative groups allow more flexible scheduling options</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', popupHTML);
        }
        
        // Close alternative popup
        function closeAlternativePopup() {
            const overlay = document.getElementById('alternativePopupOverlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Generate all possible timetable combinations
        function generateTimetableCombinations() {
            const combinationsContainer = document.getElementById('timetableCombinations');
            const container = document.getElementById('combinationsContainer');
            const timetableControls = document.getElementById('timetableControls');
            
            if (selectedLectures.length === 0) {
                combinationsContainer.style.display = 'none';
                timetableControls.style.display = 'none';
                validCombinations = [];
                clearTimetable();
                return;
            }
            
            combinationsContainer.style.display = 'block';
            
            // Group selected lectures by alternative groups
            const alternativeGroups = {};
            const independentLectures = [];
            
            selectedLectures.forEach(selected => {
                const groupId = courseToAlternativeGroup[selected.Code];
                if (groupId) {
                    if (!alternativeGroups[groupId]) {
                        alternativeGroups[groupId] = [];
                    }
                    alternativeGroups[groupId].push(selected);
                } else {
                    independentLectures.push(selected);
                }
            });
            
            // Create lecture options for combination generation
            // For alternative groups, create separate option sets for each course in the group
            const lectureOptionSets = [];
            
            // Add independent lectures (not in alternative groups)
            independentLectures.forEach(selected => {
                lectureOptionSets.push([selected]);
            });
            
            // Add alternative groups (each group becomes one option set with multiple courses)
            Object.values(alternativeGroups).forEach(groupLectures => {
                lectureOptionSets.push(groupLectures);
            });
            
            // Get all sections for each lecture option set, filtered by preferences
            const processedLectureOptions = lectureOptionSets.map(lectureSet => {
                return lectureSet.map(selected => {
                    const sectionsForCode = {};
                    allLectures.forEach(lecture => {
                        if (lecture.Code === selected.Code) {
                            // Check lecturer preference filter
                            const preferredLecturers = lecturerPreferences[selected.Code];
                            if (preferredLecturers && preferredLecturers.length > 0) {
                                if (!preferredLecturers.includes(lecture.Lecturer)) {
                                    return;
                                }
                            }
                            
                            // Check section preference filter
                            const preferredSections = sectionPreferences[selected.Code];
                            if (preferredSections && preferredSections.length > 0) {
                                if (!preferredSections.includes(lecture.Section)) {
                                    return;
                                }
                            }
                            
                            const sectionKey = lecture.Section;
                            if (!sectionsForCode[sectionKey]) {
                                sectionsForCode[sectionKey] = [];
                            }
                            sectionsForCode[sectionKey].push(lecture);
                        }
                    });
                    
                    const sectionsArray = Object.values(sectionsForCode);
                    return { courseCode: selected.Code, sections: sectionsArray };
                });
            });
            
            // Check if any processed lecture options are empty (no valid sections)
            const emptyOptions = processedLectureOptions.findIndex(optionSet => 
                optionSet.every(courseOption => courseOption.sections.length === 0)
            );
            
            if (emptyOptions !== -1) {
                container.innerHTML = `<p style="color: #dc3545; text-align: center; padding: 20px;">No sections available for some selected courses with current filters.<br>
                    <small>Please adjust your lecturer or section preferences and try again.</small></p>`;
                timetableControls.style.display = 'none';
                clearTimetable();
                return;
            }
            
            // Generate combinations respecting alternative course groups
            const combinations = generateAlternativeCombinations(processedLectureOptions);
            
            // Store all combinations for display
            validCombinations = combinations;
            
            if (validCombinations.length === 0) {
                container.innerHTML = `<p style="color: #dc3545; text-align: center; padding: 20px;">No combinations possible with current selections and alternative course constraints.</p>`;
                timetableControls.style.display = 'none';
                clearTimetable();
                return;
            }
            
            // Show timetable controls
            timetableControls.style.display = 'block';
            populateCombinationSelector();
            
            // Display combinations list with conflict information
            container.innerHTML = validCombinations.map((combination, index) => {
                const conflictCount = countTimeConflicts(combination);
                const isValidCombination = conflictCount <= maxAllowedConflicts;
                
                const conflictBadge = conflictCount > 0 ? 
                    `<span style="background: ${isValidCombination ? '#ffc107' : '#dc3545'}; color: ${isValidCombination ? '#856404' : 'white'}; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 10px;">${conflictCount} conflict${conflictCount > 1 ? 's' : ''}${isValidCombination ? '' : ' (EXCEEDS LIMIT)'}</span>` : 
                    '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 10px;">No conflicts</span>';
                
                const borderColor = isValidCombination ? (conflictCount > 0 ? '#ffc107' : '#28a745') : '#dc3545';
                const backgroundColor = isValidCombination ? 'white' : '#fff5f5';
                
                return `
                <div style="margin-bottom: 20px; padding: 15px; border: 2px solid ${borderColor}; border-radius: 10px; background: ${backgroundColor};">
                    <h4 style="margin: 0 0 15px 0; color: ${isValidCombination ? '#007bff' : '#dc3545'}; display: flex; align-items: center;">Combination ${index + 1}${conflictBadge}</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
                        ${combination.map(lectureGroup => {
                            const firstLecture = lectureGroup[0];
                            return `
                                <div style="padding: 10px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #28a745;">
                                    <div style="font-weight: bold; color: #007bff;">${firstLecture.Code} - Section ${firstLecture.Section}</div>
                                    <div style="color: #666; font-size: 14px;">${firstLecture.Name}</div>
                                    <div style="color: #333; margin-top: 5px;">${firstLecture.Lecturer}</div>
                                    <div style="color: #666; font-size: 12px; margin-top: 3px;">Excel: ${firstLecture.ExcelTime}</div>
                                    ${lectureGroup.map(lecture => 
                                        `<div style="color: #28a745; font-weight: bold; margin-top: 3px; font-size: 12px;">${lecture.Day} ${lecture.StartHour}:00-${lecture.EndHour}:00</div>`
                                    ).join('')}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <button onclick="selectCombinationInDropdown(${index})" style="margin-top: 15px; padding: 8px 16px; background: ${isValidCombination ? '#007bff' : '#6c757d'}; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        ${isValidCombination ? 'Show in Timetable' : 'View Conflicts'}
                    </button>
                </div>
                `;
            }).join('');
            
            // Auto-select first valid combination if available, otherwise first combination
            const firstValidIndex = validCombinations.findIndex(combination => countTimeConflicts(combination) <= maxAllowedConflicts);
            if (firstValidIndex !== -1) {
                currentCombinationIndex = firstValidIndex;
                displayCombinationInTimetable();
            } else if (validCombinations.length > 0) {
                currentCombinationIndex = 0;
                displayCombinationInTimetable();
            }
        }
        
        // Populate the combination selector dropdown
        function populateCombinationSelector() {
            const selector = document.getElementById('combinationSelector');
            const info = document.getElementById('combinationInfo');
            
            const validCount = validCombinations.filter(combination => countTimeConflicts(combination) <= maxAllowedConflicts).length;
            const conflictedCount = validCombinations.length - validCount;
            
            selector.innerHTML = '<option value="">Select a combination...</option>' +
                validCombinations.map((combination, index) => {
                    const conflictCount = countTimeConflicts(combination);
                    const isValid = conflictCount <= maxAllowedConflicts;
                    const conflictText = conflictCount > 0 ? ` (${conflictCount} conflicts)` : '';
                    const statusText = isValid ? '' : ' - EXCEEDS LIMIT';
                    return `<option value="${index}">Combination ${index + 1}${conflictText}${statusText}</option>`;
                }).join('');
            
            info.textContent = `${validCount} valid, ${conflictedCount} conflicted combination(s) found`;
        }
        
        // Select combination from dropdown
        function selectCombinationInDropdown(index) {
            const selector = document.getElementById('combinationSelector');
            selector.value = index;
            currentCombinationIndex = index;
            displayCombinationInTimetable();
        }
        
        // Display selected combination in timetable
        function displayCombinationInTimetable() {
            const selector = document.getElementById('combinationSelector');
            const selectedIndex = parseInt(selector.value);
            
            if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= validCombinations.length) {
                clearTimetable();
                return;
            }
            
            currentCombinationIndex = selectedIndex;
            clearTimetable();
            
            const combination = validCombinations[selectedIndex];
            console.log('Displaying combination:', selectedIndex + 1, combination);
            
            combination.forEach(lectureGroup => {
                console.log('Placing lecture group:', lectureGroup);
                lectureGroup.forEach(lecture => {
                    placeLectureInTimetable(lecture);
                });
            });
        }
        
        // Toggle time slot lock
        function toggleTimeSlotLock(day, hour) {
            const cellId = `cell_${day}_${hour}`;
            const cell = document.getElementById(cellId);
            const slotKey = `${day}_${hour}`;
            
            if (!cell) return;
            
            // Don't allow locking if cell has a lecture
            if (cell.innerHTML.trim() !== '' && !cell.classList.contains('locked')) {
                return;
            }
            
            if (lockedTimeSlots.has(slotKey)) {
                // Unlock the slot
                lockedTimeSlots.delete(slotKey);
                cell.classList.remove('locked');
                cell.innerHTML = '';
            } else {
                // Lock the slot
                lockedTimeSlots.add(slotKey);
                cell.classList.add('locked');
                cell.innerHTML = '<div class="locked-indicator">🔒</div>';
            }
            
            updateLockedSlotsDisplay();
            
            // Regenerate combinations if there are selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Update locked slots display
        function updateLockedSlotsDisplay() {
            const container = document.getElementById('lockedSlotsContainer');
            const slotsDiv = document.getElementById('lockedSlots');
            
            if (lockedTimeSlots.size === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            
            const lockedSlotsList = Array.from(lockedTimeSlots).map(slotKey => {
                const [day, hour] = slotKey.split('_');
                const nextHour = parseInt(hour) + 1;
                return `<span style="display: inline-block; margin: 2px; padding: 4px 8px; background: #fed7d7; color: #e53e3e; border-radius: 12px; font-size: 12px; border: 1px solid #e53e3e;">
                    ${day} ${hour}:00-${nextHour}:00 🔒
                </span>`;
            }).join('');
            
            slotsDiv.innerHTML = lockedSlotsList;
        }
        
        // Clear all locked slots
        function clearAllLockedSlots() {
            lockedTimeSlots.clear();
            
            // Remove visual indicators
            timeHours.forEach(hour => {
                days.forEach(day => {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    if (cell && cell.classList.contains('locked')) {
                        cell.classList.remove('locked');
                        if (cell.innerHTML.includes('locked-indicator')) {
                            cell.innerHTML = '';
                        }
                    }
                });
            });
            
            updateLockedSlotsDisplay();
            
            // Regenerate combinations if there are selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Clear the timetable - CSS Grid version
        function clearTimetable() {
            timeHours.forEach(hour => {
                days.forEach(day => {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    const slotKey = `${day}_${hour}`;
                    
                    if (cell) {
                        if (lockedTimeSlots.has(slotKey)) {
                            // Keep locked slots
                            cell.className = 'timetable-cell locked';
                            cell.innerHTML = '<div class="locked-indicator">🔒</div>';
                        } else {
                            // Clear unlocked slots
                            cell.innerHTML = '';
                            cell.className = 'timetable-cell';
                            cell.style.pointerEvents = '';
                        }
                        cell.classList.remove('occupied-continuation');
                        
                        // Remove any conflict indicators
                        const conflictIndicators = cell.querySelectorAll('.conflict-indicator');
                        conflictIndicators.forEach(indicator => indicator.remove());
                    }
                });
            });
            console.log('Modern timetable cleared, locked slots preserved');
        }
        
        // Place a lecture in the timetable with conflict visualization
        function placeLectureInTimetable(lecture) {
            if (!lecture || !lecture.Day || lecture.StartHour === undefined) {
                console.error('Invalid lecture data:', lecture);
                return;
            }
            
            const day = lecture.Day;
            const startHour = lecture.StartHour;
            const endHour = lecture.EndHour;
            const duration = endHour - startHour;
            
            // Get the assigned color for this lecture
            const lectureColor = getLectureColor(lecture.Code);
            
            // Check for conflicts with this lecture
            const conflicts = findConflictsForLecture(lecture);
            const hasConflicts = conflicts.length > 0;
            
            // Place the lecture block in the first cell and span multiple rows
            const firstCellId = `cell_${day}_${startHour}`;
            const firstCell = document.getElementById(firstCellId);
            
            if (firstCell) {
                const cellHeight = 60; // Each cell height
                const blockHeight = (duration * cellHeight) - 4;
                
                // Check if there's already a lecture in this cell (conflict)
                const existingLectures = firstCell.querySelectorAll('.lecture-block');
                
                if (existingLectures.length > 0) {
                    // Conflict situation - shrink existing lectures and add new one
                    existingLectures.forEach(block => {
                        block.classList.add('conflicted');
                        block.style.width = '45%';
                        block.style.left = '2px';
                        block.style.border = '2px solid #dc3545';
                    });
                    
                    // Create new conflicted lecture block
                    const lectureBlock = document.createElement('div');
                    lectureBlock.className = 'lecture-block multi-row conflicted';
                    lectureBlock.style.cssText = `
                        height: ${blockHeight}px;
                        background: ${lectureColor.bg};
                        color: ${lectureColor.text};
                        border: 2px solid #dc3545;
                        width: 45%;
                        right: 2px;
                        position: absolute;
                        border-radius: 8px;
                        padding: 8px 4px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        text-align: center;
                        z-index: 12;
                    `;
                    
                    lectureBlock.innerHTML = `
                        <div style="font-size: 10px; font-weight: bold; margin-bottom: 2px;">${lecture.Code}</div>
                        <div style="font-size: 8px; opacity: 0.9; margin-bottom: 2px;">Sec ${lecture.Section}</div>
                        <div style="font-size: 7px; opacity: 0.8;">${lecture.Lecturer || 'TBA'}</div>
                        <div style="font-size: 6px; color: #dc3545; font-weight: bold; margin-top: 2px;">CONFLICT</div>
                    `;
                    
                    firstCell.appendChild(lectureBlock);
                    
                    // Add central conflict indicator
                    if (!firstCell.querySelector('.conflict-indicator')) {
                        const conflictIndicator = document.createElement('div');
                        conflictIndicator.className = 'conflict-indicator';
                        conflictIndicator.innerHTML = `
                            <div>⚠️</div>
                            <div style="font-size: 8px; margin-top: 1px;">CONFLICT</div>
                            <div style="font-size: 6px;">${startHour}:00-${endHour}:00</div>
                        `;
                        firstCell.appendChild(conflictIndicator);
                    }
                } else {
                    // No conflict - place lecture normally
                    const lectureBlock = document.createElement('div');
                    lectureBlock.className = `lecture-block multi-row ${hasConflicts ? 'conflicted' : ''}`;
                    lectureBlock.style.cssText = `
                        height: ${blockHeight}px;
                        background: ${lectureColor.bg};
                        color: ${lectureColor.text};
                        border-radius: 8px;
                        padding: 12px 8px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        text-align: center;
                        position: absolute;
                        width: 100%;
                        left: 0;
                        z-index: 10;
                    `;
                    
                    lectureBlock.innerHTML = `
                        <div style="font-size: ${duration >= 3 ? '14px' : '12px'}; font-weight: bold; margin-bottom: 4px;">${lecture.Code}</div>
                        <div style="font-size: ${duration >= 3 ? '12px' : '10px'}; opacity: 0.9; margin-bottom: 4px;">Sec ${lecture.Section}</div>
                        <div style="font-size: ${duration >= 3 ? '11px' : '9px'}; opacity: 0.8;">${lecture.Lecturer || 'TBA'}</div>
                        <div style="font-size: ${duration >= 3 ? '10px' : '8px'}; opacity: 0.7; margin-top: 4px;">${startHour}:00-${endHour}:00</div>
                    `;
                    
                    firstCell.appendChild(lectureBlock);
                }
                
                // Mark subsequent cells as occupied
                for (let hour = startHour + 1; hour < endHour; hour++) {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    if (cell) {
                        cell.style.pointerEvents = 'none';
                        cell.classList.add('occupied-continuation');
                    }
                }
            }
        }
        
        // Find conflicts for a specific lecture within the current combination
        function findConflictsForLecture(targetLecture) {
            if (!validCombinations[currentCombinationIndex]) return [];
            
            const currentCombination = validCombinations[currentCombinationIndex];
            const conflicts = [];
            
            // Get all lectures in the current combination
            const allLecturesInCombination = [];
            currentCombination.forEach(lectureGroup => {
                lectureGroup.forEach(lecture => {
                    allLecturesInCombination.push(lecture);
                });
            });
            
            // Check for time overlaps with other lectures
            allLecturesInCombination.forEach(otherLecture => {
                if (otherLecture.Code !== targetLecture.Code && 
                    otherLecture.Day === targetLecture.Day) {
                    
                    // Check if time ranges overlap
                    const targetStart = targetLecture.StartHour;
                    const targetEnd = targetLecture.EndHour;
                    const otherStart = otherLecture.StartHour;
                    const otherEnd = otherLecture.EndHour;
                    
                    if (targetStart < otherEnd && otherStart < targetEnd) {
                        conflicts.push(otherLecture);
                    }
                }
            });
            
            return conflicts;
        }
        
        // Generate combinations respecting alternative course groups
        function generateAlternativeCombinations(processedLectureOptions) {
            const combinations = [];
            
            function generateRecursive(optionIndex, currentCombination) {
                if (optionIndex >= processedLectureOptions.length) {
                    combinations.push([...currentCombination]);
                    return;
                }
                
                const currentOptionSet = processedLectureOptions[optionIndex];
                
                // For each course option in this set (alternative group or single course)
                for (const courseOption of currentOptionSet) {
                    const courseCode = courseOption.courseCode;
                    const sections = courseOption.sections;
                    
                    // Skip if no sections available for this course
                    if (sections.length === 0) continue;
                    
                    // For each section of this course
                    for (const section of sections) {
                        // Add this section to the combination and recurse
                        currentCombination.push(section);
                        generateRecursive(optionIndex + 1, currentCombination);
                        currentCombination.pop();
                    }
                }
            }
            
            generateRecursive(0, []);
            return combinations;
        }
        
        // Generate all possible combinations from arrays
        function generateCombinations(arrays) {
            if (arrays.length === 0) return [[]];
            if (arrays.length === 1) return arrays[0].map(item => [item]);
            
            const result = [];
            const restCombinations = generateCombinations(arrays.slice(1));
            
            for (const item of arrays[0]) {
                for (const combination of restCombinations) {
                    result.push([item, ...combination]);
                }
            }
            
            return result;
        }
        
        // Check if a combination has time conflicts - updated for multiple time slots and locked slots
        // Global variable to store maximum allowed conflicts (already declared above)
        
        function countTimeConflicts(combination) {
            const allTimeSlots = [];
            
            // Extract all time slots from the combination
            combination.forEach(lectureGroup => {
                const lectureCode = lectureGroup[0].Code;
                const lectureSection = lectureGroup[0].Section;
                
                lectureGroup.forEach(lecture => {
                    // Add each hour as a separate slot for precise conflict detection
                    for (let hour = lecture.StartHour; hour < lecture.EndHour; hour++) {
                        allTimeSlots.push({
                            Code: lectureCode,
                            Section: lectureSection,
                            Day: lecture.Day,
                            Hour: hour,
                            StartHour: lecture.StartHour,
                            EndHour: lecture.EndHour
                        });
                    }
                });
            });
            
            let conflictHours = 0;
            
            // Check for conflicts with locked time slots
            allTimeSlots.forEach(slot => {
                const slotKey = `${slot.Day}_${slot.Hour}`;
                if (lockedTimeSlots.has(slotKey)) {
                    conflictHours++;
                }
            });
            
            // Check for conflicts between lectures
            for (let i = 0; i < allTimeSlots.length; i++) {
                for (let j = i + 1; j < allTimeSlots.length; j++) {
                    const slot1 = allTimeSlots[i];
                    const slot2 = allTimeSlots[j];
                    
                    // Skip if same lecture
                    if (slot1.Code === slot2.Code && slot1.Section === slot2.Section) {
                        continue;
                    }
                    
                    // Check if same day and hour (conflict)
                    if (slot1.Day === slot2.Day && slot1.Hour === slot2.Hour) {
                        conflictHours++;
                        console.log(`Conflict detected: ${slot1.Code} vs ${slot2.Code} at ${slot1.Day} ${slot1.Hour}:00`);
                        break; // Count each conflicting hour only once
                    }
                }
            }
            
            return conflictHours;
        }
        
        function hasTimeConflict(combination) {
            const conflicts = countTimeConflicts(combination);
            return conflicts > maxAllowedConflicts;
        }
        
        // Check if two time ranges overlap
        function timeRangesOverlap(range1, range2) {
            return range1.start < range2.end && range2.start < range1.end;
        }
        
        // Find conflicts for a specific lecture within the current combination
        function findConflictsForLecture(targetLecture) {
            if (!validCombinations[currentCombinationIndex]) return [];
            
            const currentCombination = validCombinations[currentCombinationIndex];
            const conflicts = [];
            
            // Get all lectures in the current combination
            const allLecturesInCombination = [];
            currentCombination.forEach(lectureGroup => {
                lectureGroup.forEach(lecture => {
                    allLecturesInCombination.push(lecture);
                });
            });
            
            // Check for time overlaps with other lectures
            allLecturesInCombination.forEach(otherLecture => {
                if (otherLecture.Code !== targetLecture.Code && 
                    otherLecture.Day === targetLecture.Day) {
                    
                    // Check if time ranges overlap
                    const targetStart = targetLecture.StartHour;
                    const targetEnd = targetLecture.EndHour;
                    const otherStart = otherLecture.StartHour;
                    const otherEnd = otherLecture.EndHour;
                    
                    if (targetStart < otherEnd && otherStart < targetEnd) {
                        conflicts.push(otherLecture);
                    }
                }
            });
            
            return conflicts;
        }
        
        // Global variable to store maximum allowed conflicts
        let maxAllowedConflicts = 0;
        
        // Update conflict settings when slider changes
        function updateConflictSettings() {
            const slider = document.getElementById('maxConflicts');
            const valueDisplay = document.getElementById('conflictValue');
            
            maxAllowedConflicts = parseInt(slider.value);
            valueDisplay.textContent = maxAllowedConflicts;
            
            console.log('Maximum allowed conflicts set to:', maxAllowedConflicts);
            
            // Regenerate combinations if lectures are already selected
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }

        // Toggle Selected Lectures visibility
        function toggleSelectedLecturesVisibility() {
            const lecturesDiv = document.getElementById('selectedLectures');
            const button = document.getElementById('minimizeSelectedButton');
            const isMinimized = lecturesDiv.style.display === 'none';
            
            if (isMinimized) {
                // Expand
                lecturesDiv.style.display = 'block';
                button.innerHTML = '▲';
                button.title = 'Minimize Selected Lectures';
            } else {
                // Minimize
                lecturesDiv.style.display = 'none';
                button.innerHTML = '▼';
                button.title = 'Show Selected Lectures';
            }
        }
        </script>
</body>
</html>