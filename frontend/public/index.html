<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <h2></h2>
    <title>University Schedule Creator</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            padding: 2rem;
            max-height: 100vh;
            overflow: hidden;
        }
        
        .left-column {
            flex: 0.7;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }
        
        .right-column {
            flex: 1.3;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }
        
        .page-title {
            text-align: center;
            margin: 0 0 2rem 0;
            font-size: 28px;
            color: #333;
            font-weight: bold;
        }
        
        .search-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .search-container h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            border-color: #007bff;
            outline: none;
        }
        
        .lecture-list {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }
        
        .lecture-item {
            margin: 8px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            transition: all 0.2s;
        }
        
        .lecture-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0,123,255,0.15);
        }
        
        .selected-lectures-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }
        
        .selected-lectures-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .combinations-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .combinations-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .selected-lecture-tag {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-radius: 20px;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }
        
        .remove-btn {
            margin-left: 8px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        
        .remove-btn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .timetable {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .timetable-section {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .timetable-section h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 22px;
            text-align: center;
        }
        
        .timetable-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin: 0;
            flex: 1;
        }
        
        .timetable-grid {
            display: grid;
            grid-template-columns: 120px repeat(5, 1fr);
            grid-template-rows: 60px repeat(11, 60px);
            gap: 1px;
            background-color: #e2e8f0;
            font-family: 'Arial', sans-serif;
        }
        
        .timetable-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            padding: 10px;
        }
        
        .time-slot {
            background: #f8fafc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #4a5568;
            font-size: 14px;
            border-right: 2px solid #e2e8f0;
        }
        
        .timetable-cell {
            background: #ffffff;
            position: relative;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
            min-height: 58px;
            cursor: pointer;
        }
        
        .timetable-cell:hover {
            background: #f7fafc;
            transform: scale(1.02);
            z-index: 1;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .timetable-cell.locked {
            background: #fed7d7 !important;
            border: 2px solid #e53e3e !important;
            cursor: pointer;
        }
        
        .timetable-cell.locked:hover {
            background: #feb2b2 !important;
            transform: scale(1.02);
        }
        
        .locked-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #e53e3e;
            pointer-events: none;
        }
        
        .lecture-block {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 54px; /* Fixed height to match timetable cell (58px - 4px for top/bottom margins) */
            border-radius: 8px;
            padding: 8px;
            color: white;
            font-size: 11px;
            line-height: 1.2;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        .lecture-block:hover {
            transform: scale(1.02);
            z-index: 20;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .lecture-block.multi-row {
            position: absolute;
            border-radius: 8px;
            padding: 12px 8px;
            height: auto; /* Multi-row blocks can span multiple cells, so use auto height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        
        .occupied-continuation {
            background-color: transparent !important;
            border: none !important;
            position: relative;
            z-index: 5;
        }
        
        .lecture-code {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 2px;
        }
        
        .lecture-section {
            font-size: 10px;
            opacity: 0.9;
            margin-bottom: 2px;
        }
        
        .lecture-lecturer {
            font-size: 9px;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .lecture-continuation {
            background: linear-gradient(135deg, #4299e1, #3182ce) !important;
            justify-content: center;
            align-items: center;
        }
        
        .lecture-colors {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        
        .lecture-colors-alt {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }
        
        .lecture-colors-alt2 {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }
        
        .lecture-colors-alt3 {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
        }
        
        .lecture-colors-alt4 {
            background: linear-gradient(135deg, #fa709a, #fee140);
        }
        
        .conflict-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.95);
            color: white;
            padding: 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.4);
            z-index: 15;
            border: 2px solid #dc3545;
        }
        
        .conflict-box {
            background: linear-gradient(135deg, #dc3545, #c82333) !important;
            border: 2px solid #dc3545 !important;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.6) !important;
            animation: conflictPulse 2s infinite;
        }
        
        @keyframes conflictPulse {
            0%, 100% { box-shadow: 0 2px 8px rgba(220, 53, 69, 0.6); }
            50% { box-shadow: 0 4px 16px rgba(220, 53, 69, 0.8); }
        }
        
                .conflict-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.95);
            color: white;
            padding: 4px 6px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.4);
            z-index: 20;
            border: 2px solid #dc3545;
            backdrop-filter: blur(2px);
        }
        
        .conflict-box {
            background: linear-gradient(135deg, #dc3545, #c82333) !important;
            border: 2px solid #dc3545 !important;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.6) !important;
            animation: conflictPulse 2s infinite;
        }
        
        @keyframes conflictPulse {
            0%, 100% { box-shadow: 0 2px 8px rgba(220, 53, 69, 0.6); }
            50% { box-shadow: 0 4px 16px rgba(220, 53, 69, 0.8); }
        }
        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                max-height: none;
                overflow: visible;
            }
            
            .left-column,
            .right-column {
                max-height: none;
                overflow-y: visible;
            }
            
            .timetable-grid {
                grid-template-columns: 80px repeat(5, 1fr);
                grid-template-rows: 50px repeat(11, 50px);
                font-size: 12px;
            }
            
            .timetable-header {
                font-size: 14px;
                padding: 8px;
            }
            
            .time-slot {
                font-size: 12px;
            }
            
            .lecture-block {
                padding: 4px;
                font-size: 10px;
            }
        }
        
        /* Export controls styling */
        .export-container {
            border: 1px solid #e9ecef !important;
        }
        
        .export-container button {
            transition: all 0.2s ease;
            font-weight: 500;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .export-container button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .export-container button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            transform: none;
            box-shadow: none;
        }
        
        .export-container button:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        .combination-export-checkbox {
            accent-color: #007bff;
        }
        
        .combination-export-checkbox:checked {
            background-color: #007bff;
            border-color: #007bff;
        }
    </style>
</head>
<body>
        <div id="root"></div>
        <h1 class="page-title">University Schedule Creator</h1>
        
        <div class="main-container">
            <!-- Left Column -->
            <div class="left-column">
                <!-- Search and Lecture Selection Section -->
                <div class="search-container">
                    <h2>Search and Select Lectures</h2>
                    <div style="margin-bottom: 1rem;">
                        <input type="text" id="lectureSearch" placeholder="Search for lectures, codes, or lecturers..." 
                               class="search-input">
                    </div>
                    
                    <div id="lectureList" class="lecture-list" style="padding: 10px;">
                        <div id="loadingMessage" style="text-align: center; color: #666;">Loading lectures...</div>
                        <div id="lectureResults"></div>
                    </div>
                </div>
                
                <!-- Conflict Settings Section -->
                <div class="conflict-settings-container" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px; border: 1px solid #e9ecef;">
                    <h3 style="margin: 0 0 15px 0; color: #495057;">Timetable Settings</h3>
                    
                    <!-- Conflict Settings -->
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px;">
                        <label for="maxConflicts" style="font-weight: 500; color: #495057;">Maximum Conflicting Hours Allowed:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="range" id="maxConflicts" min="0" max="10" value="0" 
                                   style="flex: 1;" onchange="updateConflictSettings()">
                            <span id="conflictValue" style="font-weight: bold; color: #007bff; min-width: 30px;">0</span>
                        </div>
                        <small style="color: #6c757d;">Set to 0 for no conflicts (default), increase to allow overlapping lectures</small>
                    </div>
                    
                    <!-- Empty Days Settings -->
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label for="minEmptyDays" style="font-weight: 500; color: #495057;">Minimum Empty Days Required:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="range" id="minEmptyDays" min="0" max="5" value="0" 
                                   style="flex: 1;" onchange="updateEmptyDaysSettings()">
                            <span id="emptyDaysValue" style="font-weight: bold; color: #28a745; min-width: 30px;">0</span>
                        </div>
                        <small style="color: #6c757d;">Set to 0 for no requirement (default), increase to require more free days</small>
                    </div>
                </div>
                
                <!-- Session Management -->
                <div class="session-management-container" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px; border: 1px solid #e9ecef;">
                    <h3 style="margin: 0 0 15px 0; color: #495057;">Session Management</h3>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center;">
                        <button 
                            onclick="exportSession()" 
                            style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;"
                            onmouseover="this.style.backgroundColor='#218838'"
                            onmouseout="this.style.backgroundColor='#28a745'"
                        >
                            üíæ Export Session
                        </button>
                        
                        <button 
                            onclick="importSession()" 
                            style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;"
                            onmouseover="this.style.backgroundColor='#0056b3'"
                            onmouseout="this.style.backgroundColor='#007bff'"
                        >
                            üìÅ Import Session
                        </button>
                        
                        <button 
                            onclick="clearCachedSession()" 
                            style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;"
                            onmouseover="this.style.backgroundColor='#bd2130'"
                            onmouseout="this.style.backgroundColor='#dc3545'"
                        >
                            üóëÔ∏è Clear Cache
                        </button>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 5px; border-left: 4px solid #2196f3;">
                        <strong style="color: #1976d2;">üß™ Test Import Function</strong><br>
                        <small style="color: #666; margin-bottom: 8px; display: block;">Test the import functionality with the provided JSON session file</small>
                        <button 
                            onclick="testImportProvidedSession()" 
                            style="padding: 8px 16px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s;"
                            onmouseover="this.style.backgroundColor='#1976d2'"
                            onmouseout="this.style.backgroundColor='#2196f3'"
                        >
                            üî¨ Test Import Session
                        </button>
                    </div>
                    <div style="margin-top: 10px; color: #6c757d; font-size: 12px;">
                        <div>‚Ä¢ Auto-saves every 30 seconds and on page close</div>
                        <div>‚Ä¢ Export includes: lectures, preferences, settings, locked slots</div>
                        <div>‚Ä¢ Import will restore complete session state</div>
                    </div>
                </div>
                
                <!-- Export Controls -->
                <div id="exportControls" class="export-container" style="display: none; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px;">
                    <h3 style="margin-top: 0; margin-bottom: 15px; color: #333; font-size: 18px;">Export Combinations</h3>
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px; flex-wrap: wrap;">
                        <button onclick="selectAllCombinationsForExport()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.2s;">Select All</button>
                        <button onclick="clearAllCombinationSelections()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.2s;">Clear All</button>
                        <button onclick="exportSelectedCombinations()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: all 0.2s;" disabled>Export Selected as PNG</button>
                        <span id="exportStatus" style="margin-left: 10px; color: #666; font-size: 14px;"></span>
                    </div>
                    <div id="selectedCountDisplay" style="color: #666; font-size: 14px;">0 combinations selected for export</div>
                </div>
                
                <!-- Possible Timetable Combinations -->
                <div id="timetableCombinations" class="combinations-container" style="display: none;">
                    <h3>Possible Timetable Combinations:</h3>
                    <div id="combinationsContainer" style="flex: 1; overflow-y: auto;">
                    </div>
                </div>
            </div>
            
            <!-- Right Column -->
            <div class="right-column">
                <!-- Selected Lectures -->
                <div class="selected-lectures-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Selected Lectures:</h3>
                        <button id="minimizeSelectedButton" onclick="toggleSelectedLecturesVisibility()" 
                                style="background: #6c757d; color: white; border: none; border-radius: 6px; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: all 0.2s ease;"
                                onmouseover="this.style.background='#5a6268'" onmouseout="this.style.background='#6c757d'">
                            ‚ñ≤
                        </button>
                    </div>
                    <div id="selectedLectures" style="min-height: 50px;">
                        <p style="color: #666; margin: 0;">No lectures selected yet.</p>
                    </div>
                </div>
                
                <!-- Locked Time Slots -->
                <div id="lockedSlotsContainer" class="selected-lectures-container" style="display: none;">
                    <h3>Locked Time Slots:</h3>
                    <div id="lockedSlots" style="min-height: 30px;">
                        <p style="color: #666; margin: 0; font-size: 14px;">Click on empty timetable cells to lock them.</p>
                    </div>
                    <button onclick="clearAllLockedSlots()" style="margin-top: 10px; padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Clear All Locked Slots
                    </button>
                </div>
                
                <!-- Timetable Controls -->
                <div id="timetableControls" style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: none;">
                    <!-- Bookmarked Combinations -->
                    <div id="bookmarkedCombinations" style="margin-bottom: 15px; display: none;">
                        <h4 style="margin: 0 0 10px 0; color: #007bff;">üìå Bookmarked Combinations</h4>
                        <div id="bookmarkedList" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;">
                            <!-- Bookmarked combinations will appear here -->
                        </div>
                    </div>
                    
                    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label style="font-weight: bold; margin-right: 10px;">Timetable Combination:</label>
                            <select id="combinationSelector" onchange="displayCombinationInTimetable()" style="padding: 8px; border: 2px solid #e0e0e0; border-radius: 5px; background: white;">
                                <option value="">Select a combination...</option>
                            </select>
                            
                            <!-- Combination Action Buttons -->
                            <button id="bookmarkBtn" onclick="toggleBookmarkCombination()" style="padding: 6px 12px; background: #ffc107; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; display: none;" title="Bookmark this combination">
                                ‚≠ê Bookmark
                            </button>
                            <button id="deleteBtn" onclick="deleteCombination()" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; display: none;" title="Delete this combination">
                                üóëÔ∏è Delete
                            </button>
                        </div>
                        <div style="color: #666; font-size: 14px;">
                            <span id="combinationInfo"></span>
                        </div>
                    </div>
                </div>
                
                <!-- Weekly Timetable -->
                <div class="timetable-section">
                    <h2>Weekly Timetable</h2>
                    
                    <div class="timetable-container">
                        <div class="timetable-grid" id="timetableGrid">
                            <!-- Timetable will be generated dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <script>
        // Lecture data and functionality
        let allLectures = [];
        let selectedLectures = [];
        let validCombinations = [];
        let currentCombinationIndex = 0;
        let lockedTimeSlots = new Set(); // Format: "Day_Hour" (e.g., "Monday_10")
        let lecturerPreferences = {}; // Object to store preferred lecturers for each lecture code
        let sectionPreferences = {}; // Object to store preferred sections for each lecture code
        let lectureColors = {}; // Object to store assigned colors for each lecture code
        
        // Export functionality
        let selectedCombinationsForExport = new Set(); // Set to track which combinations are selected for export
        
        // Alternative course management
        let alternativeCourseGroups = {}; // Object to store alternative course groups: {groupId: [courseCode1, courseCode2]}
        let courseToAlternativeGroup = {}; // Object to map course codes to their alternative group ID
        let alternativeGroupCounter = 0; // Counter to generate unique group IDs
        
        // Combination management
        let deletedCombinations = new Set(); // Set to track deleted combination indices
        let bookmarkedCombinations = new Set(); // Set to track bookmarked combination indices
        
        // ============ SESSION STATE MANAGEMENT ============
        
        // Collect complete application state for export/cache
        function collectSessionState() {
            // Get current slider values
            const maxConflictsSlider = document.getElementById('maxConflicts');
            const emptyDaysSlider = document.getElementById('minEmptyDays');
            
            const sessionState = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                applicationState: {
                    // Core lecture data
                    selectedLectures: selectedLectures,
                    currentCombinationIndex: currentCombinationIndex,
                    
                    // User preferences
                    lecturerPreferences: lecturerPreferences,
                    sectionPreferences: sectionPreferences,
                    lectureColors: lectureColors,
                    
                    // Locked time slots (convert Set to Array for JSON)
                    lockedTimeSlots: Array.from(lockedTimeSlots),
                    
                    // Slider settings
                    maxAllowedConflicts: maxConflictsSlider ? parseInt(maxConflictsSlider.value) : 0,
                    minRequiredEmptyDays: emptyDaysSlider ? parseInt(emptyDaysSlider.value) : 0,
                    
                    // Alternative course groups
                    alternativeCourseGroups: alternativeCourseGroups,
                    courseToAlternativeGroup: courseToAlternativeGroup,
                    alternativeGroupCounter: alternativeGroupCounter,
                    
                    // Combination management (convert Set to Array for JSON)
                    deletedCombinations: Array.from(deletedCombinations),
                    bookmarkedCombinations: Array.from(bookmarkedCombinations),
                    
                    // Export selections (convert Set to Array for JSON)
                    selectedCombinationsForExport: Array.from(selectedCombinationsForExport)
                }
            };
            
            return sessionState;
        }
        
        // Restore application state from imported/cached data
        function restoreSessionState(sessionState) {
            try {
                if (!sessionState.applicationState) {
                    throw new Error('Invalid session state format');
                }
                
                const state = sessionState.applicationState;
                
                // Restore core data
                selectedLectures = state.selectedLectures || [];
                currentCombinationIndex = state.currentCombinationIndex || 0;
                
                // Restore preferences
                lecturerPreferences = state.lecturerPreferences || {};
                sectionPreferences = state.sectionPreferences || {};
                lectureColors = state.lectureColors || {};
                
                // Restore locked time slots (convert Array back to Set)
                lockedTimeSlots = new Set(state.lockedTimeSlots || []);
                
                // Restore alternative course groups
                alternativeCourseGroups = state.alternativeCourseGroups || {};
                courseToAlternativeGroup = state.courseToAlternativeGroup || {};
                alternativeGroupCounter = state.alternativeGroupCounter || 0;
                
                // Restore combination management (convert Array back to Set)
                deletedCombinations = new Set(state.deletedCombinations || []);
                bookmarkedCombinations = new Set(state.bookmarkedCombinations || []);
                
                // Restore export selections (convert Array back to Set)
                selectedCombinationsForExport = new Set(state.selectedCombinationsForExport || []);
                
                // Restore slider values and update global variables
                const maxConflictsSlider = document.getElementById('maxConflicts');
                const emptyDaysSlider = document.getElementById('minEmptyDays');
                
                if (maxConflictsSlider) {
                    maxConflictsSlider.value = state.maxAllowedConflicts || 0;
                    maxAllowedConflicts = parseInt(maxConflictsSlider.value);
                    // Trigger change event to update display and variables
                    maxConflictsSlider.dispatchEvent(new Event('change'));
                }
                
                if (emptyDaysSlider) {
                    emptyDaysSlider.value = state.minRequiredEmptyDays || 0;
                    minRequiredEmptyDays = parseInt(emptyDaysSlider.value);
                    // Trigger change event to update display and variables
                    emptyDaysSlider.dispatchEvent(new Event('change'));
                }
                
                // Update UI to reflect restored state
                updateUIAfterStateRestore();
                
                console.log('Session state restored successfully', sessionState);
                return true;
                
            } catch (error) {
                console.error('Failed to restore session state:', error);
                alert('Failed to restore session state: ' + error.message);
                return false;
            }
        }
        
        // Update UI elements after state restoration
        function updateUIAfterStateRestore() {
            // Wait for lectures to be loaded if they aren't already
            if (allLectures.length === 0) {
                console.log('Lectures not loaded yet, waiting...');
                // Try again after a short delay
                setTimeout(updateUIAfterStateRestore, 500);
                return;
            }
            
            // Update lecture selections in the UI
            const checkboxes = document.querySelectorAll('input[type="checkbox"][data-lecture-code]');
            checkboxes.forEach(checkbox => {
                const lectureCode = checkbox.getAttribute('data-lecture-code');
                const isSelected = selectedLectures.some(l => l.Code === lectureCode);
                checkbox.checked = isSelected;
            });
            
            // Update selected lectures display
            updateSelectedLecturesDisplay();
            
            // Update locked time slots visualization
            updateLockedSlotsDisplay();
            
            // Update alternative course groups display
            updateAlternativeCourseGroupsDisplay();
            
            // Regenerate combinations with restored state
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
            
            // Update timetable display
            if (validCombinations.length > 0) {
                displayCombinationInTimetable();
            }
            
            console.log('UI updated after state restoration');
        }
        
        // Update alternative course groups display after state restoration
        function updateAlternativeCourseGroupsDisplay() {
            // Find all alternative course indicators in the UI and update them
            const lectureElements = document.querySelectorAll('[data-lecture-code]');
            lectureElements.forEach(element => {
                const lectureCode = element.getAttribute('data-lecture-code');
                if (isInAlternativeGroup(lectureCode)) {
                    // Add visual indicator if not already present
                    const existingIndicator = element.querySelector('.alternative-indicator');
                    if (!existingIndicator) {
                        const indicator = document.createElement('span');
                        indicator.className = 'alternative-indicator';
                        indicator.style.cssText = 'color: #007bff; font-weight: bold; margin-left: 5px;';
                        indicator.textContent = '(ALT)';
                        element.appendChild(indicator);
                    }
                }
            });
        }
        
        // Update the selected lectures display
        function updateSelectedLecturesDisplay() {
            const selectedLecturesContainer = document.getElementById('selectedLectures');
            if (!selectedLecturesContainer) {
                console.log('Selected lectures container not found');
                return;
            }
            
            if (selectedLectures.length === 0) {
                selectedLecturesContainer.innerHTML = '<p style="color: #6c757d; font-style: italic;">No lectures selected</p>';
                return;
            }
            
            const lecturesHTML = selectedLectures.map(lecture => `
                <div style="background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 5px; border-left: 4px solid #007bff;">
                    <strong>${lecture.Code}</strong> - ${lecture.Name}<br>
                    <small style="color: #6c757d;">Section: ${lecture.Section} | Lecturer: ${lecture.Lecturer}</small>
                </div>
            `).join('');
            
            selectedLecturesContainer.innerHTML = lecturesHTML;
        }
        
        // Auto-save to localStorage
        function autoSaveSession() {
            try {
                const sessionState = collectSessionState();
                localStorage.setItem('universitySchedulerSession', JSON.stringify(sessionState));
                console.log('Session auto-saved to localStorage');
            } catch (error) {
                console.error('Failed to auto-save session:', error);
            }
        }
        
        // Auto-load from localStorage
        function autoLoadSession() {
            try {
                const savedSession = localStorage.getItem('universitySchedulerSession');
                if (savedSession) {
                    const sessionState = JSON.parse(savedSession);
                    console.log('Found saved session, restoring...', sessionState);
                    return restoreSessionState(sessionState);
                }
                return false;
            } catch (error) {
                console.error('Failed to auto-load session:', error);
                return false;
            }
        }
        
        // Clear cached session
        function clearCachedSession() {
            try {
                localStorage.removeItem('universitySchedulerSession');
                console.log('Cached session cleared');
                alert('Cached session data has been cleared.');
            } catch (error) {
                console.error('Failed to clear cached session:', error);
            }
        }
        
        // Export session to file
        function exportSession() {
            try {
                const sessionState = collectSessionState();
                const jsonString = JSON.stringify(sessionState, null, 2);
                
                // Create and download file
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `university-scheduler-session-${timestamp}.json`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`Session exported successfully as ${filename}`);
                
            } catch (error) {
                console.error('Failed to export session:', error);
                alert('Failed to export session: ' + error.message);
            }
        }
        
        // Import session from file
        function importSession() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const sessionState = JSON.parse(e.target.result);
                        
                        // Validate file format
                        if (!sessionState.version || !sessionState.applicationState) {
                            throw new Error('Invalid session file format. Please ensure this is a valid University Scheduler session file.');
                        }
                        
                        // Show detailed import information
                        const state = sessionState.applicationState;
                        const lectureCount = state.selectedLectures ? state.selectedLectures.length : 0;
                        const alternativeGroups = Object.keys(state.alternativeCourseGroups || {}).length;
                        
                        const confirmMessage = `Import session from ${sessionState.timestamp}?\n\n` +
                            `This session contains:\n` +
                            `‚Ä¢ ${lectureCount} selected lectures\n` +
                            `‚Ä¢ ${alternativeGroups} alternative course groups\n` +
                            `‚Ä¢ Max conflicts: ${state.maxAllowedConflicts || 0}\n` +
                            `‚Ä¢ Min empty days: ${state.minRequiredEmptyDays || 0}\n\n` +
                            `This will replace your current settings and selections.`;
                        
                        if (confirm(confirmMessage)) {
                            console.log('Importing session:', sessionState);
                            if (restoreSessionState(sessionState)) {
                                alert(`Session imported successfully!\n\nLoaded ${lectureCount} lectures with ${alternativeGroups} alternative groups.`);
                            }
                        }
                        
                    } catch (error) {
                        console.error('Failed to import session:', error);
                        alert('Failed to import session: ' + error.message + '\n\nPlease ensure the file is a valid University Scheduler session file.');
                    }
                };
                
                reader.readAsText(file);
            });
            
            input.click();
        }
        
        // Setup auto-save on important state changes
        function setupAutoSave() {
            // Auto-save when page is about to unload
            window.addEventListener('beforeunload', autoSaveSession);
            
            // Auto-save periodically (every 30 seconds)
            setInterval(autoSaveSession, 30000);
        }
        
        // ============ END SESSION STATE MANAGEMENT ============
        
        // Test function to import the provided JSON session directly
        function testImportProvidedSession() {
            const testSessionData = {
              "version": "1.0",
              "timestamp": "2025-09-11T23:27:10.566Z",
              "applicationState": {
                "selectedLectures": [
                  {
                    "Code": "CMPE 361",
                    "Name": "Computer Organization",
                    "Section": "CMPE 361_01",
                    "Hours": 3,
                    "Lecturer": "Saiful Islam ",
                    "Room": "D028",
                    "ExcelTime": "Tu 15 - 17 Fr 09 - 11",
                    "Department": "Department of Computer Engineering",
                    "Category": "Course",
                    "ECTS": 6,
                    "Day": "Tuesday",
                    "StartHour": 15,
                    "EndHour": 17,
                    "TimeSlotIndex": 0
                  },
                  {
                    "Code": "CMPE 223",
                    "Name": "Data Structures and Algorithms I",
                    "Section": "CMPE 223_01",
                    "Hours": 3,
                    "Lecturer": "Ula√æ G√ºle√ß ",
                    "Room": "D028",
                    "ExcelTime": "Th 09 - 11 Fr 13 - 14",
                    "Department": "Department of Computer Engineering",
                    "Category": "Course",
                    "ECTS": 6,
                    "Day": "Thursday",
                    "StartHour": 9,
                    "EndHour": 11,
                    "TimeSlotIndex": 0
                  },
                  {
                    "Code": "CMPE 472",
                    "Name": "Computer Networks",
                    "Section": "CMPE 472_01",
                    "Hours": 3,
                    "Lecturer": "Emin Ku√∞u ",
                    "Room": "A514-PC-L",
                    "ExcelTime": "Mo 11 - 13 Tu 09 - 11",
                    "Department": "Department of Computer Engineering",
                    "Category": "Course",
                    "ECTS": 6,
                    "Day": "Monday",
                    "StartHour": 11,
                    "EndHour": 13,
                    "TimeSlotIndex": 0
                  },
                  {
                    "Code": "SOC 103",
                    "Name": "Introduction to Sociology",
                    "Section": "SOC 103_01",
                    "Hours": 3,
                    "Lecturer": "G√ºl √áorbac√Ωo√∞lu Aksak (S) ",
                    "Room": "G003",
                    "ExcelTime": "We 16 - 19",
                    "Department": "Department of Sociology",
                    "Category": "Course",
                    "ECTS": 5,
                    "Day": "Wednesday",
                    "StartHour": 16,
                    "EndHour": 19,
                    "TimeSlotIndex": 0
                  },
                  {
                    "Code": "ECON 101-O",
                    "Name": "Economics I",
                    "Section": "ECON 101-O_1",
                    "Hours": 4,
                    "Lecturer": "G√ºnnur Ege Bilgin (S) ",
                    "Room": "D026",
                    "ExcelTime": "Tu 13 - 16 Th 14 - 16",
                    "Department": "Department of Economics",
                    "Category": "Course",
                    "ECTS": 6,
                    "Day": "Tuesday",
                    "StartHour": 13,
                    "EndHour": 16,
                    "TimeSlotIndex": 0
                  }
                ],
                "currentCombinationIndex": 0,
                "lecturerPreferences": {},
                "sectionPreferences": {},
                "lectureColors": {
                  "CMPE 361": {
                    "bg": "linear-gradient(135deg, #26c6da, #00bcd4)",
                    "text": "white"
                  },
                  "CMPE 223": {
                    "bg": "linear-gradient(135deg, #26c6da, #00bcd4)",
                    "text": "white"
                  },
                  "CMPE 472": {
                    "bg": "linear-gradient(135deg, #4db6ac, #009688)",
                    "text": "white"
                  },
                  "SOC 103": {
                    "bg": "linear-gradient(135deg, #90a4ae, #607d8b)",
                    "text": "white"
                  },
                  "ECON 101-O": {
                    "bg": "linear-gradient(135deg, #667eea, #764ba2)",
                    "text": "white"
                  }
                },
                "lockedTimeSlots": [],
                "maxAllowedConflicts": 1,
                "minRequiredEmptyDays": 0,
                "alternativeCourseGroups": {
                  "alt_group_0": [
                    "SOC 103",
                    "ECON 101-O"
                  ],
                  "alt_group_2": [
                    "CMPE 361",
                    "CMPE 223"
                  ]
                },
                "courseToAlternativeGroup": {
                  "SOC 103": "alt_group_0",
                  "ECON 101-O": "alt_group_0",
                  "CMPE 361": "alt_group_2",
                  "CMPE 223": "alt_group_2"
                },
                "alternativeGroupCounter": 3,
                "selectedCombinationsForExport": []
              }
            };
            
            console.log('Testing import of provided session data...');
            if (restoreSessionState(testSessionData)) {
                alert('Test session imported successfully!\\n\\n' +
                      '5 lectures loaded:\\n' +
                      '‚Ä¢ CMPE 361 - Computer Organization\\n' +
                      '‚Ä¢ CMPE 223 - Data Structures and Algorithms I\\n' +
                      '‚Ä¢ CMPE 472 - Computer Networks\\n' +
                      '‚Ä¢ SOC 103 - Introduction to Sociology\\n' +
                      '‚Ä¢ ECON 101-O - Economics I\\n\\n' +
                      '2 alternative course groups created');
            }
        }
        
        // Simple time structure - each hour from 9 to 19
        const timeHours = [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
        const days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        const dayColumnMap = {
            "Monday": 1,
            "Tuesday": 2, 
            "Wednesday": 3,
            "Thursday": 4,
            "Friday": 5
        };
        
        // Process lectures to parse time slots from Excel format
        function processLectures(rawLectures) {
            const processedLectures = [];
            
            rawLectures.forEach(lecture => {
                const timeSlots = parseExcelTime(lecture.ExcelTime);
                
                if (timeSlots.length === 0) {
                    console.warn('No valid time slots found for lecture:', lecture);
                    return;
                }
                
                // Parse room assignments for each time slot
                const roomAssignments = parseRoomAssignments(lecture.Room, timeSlots);
                
                // Create a lecture entry for each time slot
                timeSlots.forEach((timeSlot, index) => {
                    processedLectures.push({
                        ...lecture,
                        Day: timeSlot.Day,
                        StartHour: timeSlot.StartHour,
                        EndHour: timeSlot.EndHour,
                        Room: roomAssignments[index] || 'TBA',
                        TimeSlotIndex: index // To track multiple slots for same lecture
                    });
                });
            });
            
            return processedLectures;
        }
        
        // Color generation and assignment functions
        function generateRandomColor() {
            const colors = [
                { bg: 'linear-gradient(135deg, #667eea, #764ba2)', text: 'white' },
                { bg: 'linear-gradient(135deg, #f093fb, #f5576c)', text: 'white' },
                { bg: 'linear-gradient(135deg, #4facfe, #00f2fe)', text: 'white' },
                { bg: 'linear-gradient(135deg, #43e97b, #38f9d7)', text: 'white' },
                { bg: 'linear-gradient(135deg, #fa709a, #fee140)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ff9a9e, #fecfef)', text: 'white' },
                { bg: 'linear-gradient(135deg, #a18cd1, #fbc2eb)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffecd2, #fcb69f)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ff8a80, #ff5722)', text: 'white' },
                { bg: 'linear-gradient(135deg, #81c784, #4caf50)', text: 'white' },
                { bg: 'linear-gradient(135deg, #64b5f6, #2196f3)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ba68c8, #9c27b0)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffb74d, #ff9800)', text: 'white' },
                { bg: 'linear-gradient(135deg, #4db6ac, #009688)', text: 'white' },
                { bg: 'linear-gradient(135deg, #f06292, #e91e63)', text: 'white' },
                { bg: 'linear-gradient(135deg, #aed581, #8bc34a)', text: 'white' },
                { bg: 'linear-gradient(135deg, #90a4ae, #607d8b)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ffcc02, #ffc107)', text: 'white' },
                { bg: 'linear-gradient(135deg, #26c6da, #00bcd4)', text: 'white' },
                { bg: 'linear-gradient(135deg, #ab47bc, #8e24aa)', text: 'white' }
            ];
            
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function assignLectureColor(lectureCode) {
            if (!lectureColors[lectureCode]) {
                lectureColors[lectureCode] = generateRandomColor();
                console.log(`Assigned color to ${lectureCode}:`, lectureColors[lectureCode]);
            }
            return lectureColors[lectureCode];
        }
        
        function getLectureColor(lectureCode) {
            return lectureColors[lectureCode] || { bg: 'linear-gradient(135deg, #667eea, #764ba2)', text: 'white' };
        }
        
        // Day name mapping
        const dayMapping = {
            'Mo': 'Monday',
            'Tu': 'Tuesday', 
            'We': 'Wednesday',
            'Th': 'Thursday',
            'Fr': 'Friday'
        };
        
        // Parse room information to match time slots
        function parseRoomAssignments(roomString, timeSlots) {
            if (!roomString || !timeSlots || timeSlots.length === 0) {
                return timeSlots.map(() => 'TBA');
            }
            
            // Split rooms by spaces and filter out empty strings
            const rooms = roomString.trim().split(/\s+/).filter(room => room.trim());
            
            // If we have equal number of rooms and time slots, assign directly
            if (rooms.length === timeSlots.length) {
                return rooms;
            }
            
            // If we have only one room, assign it to all time slots
            if (rooms.length === 1) {
                return timeSlots.map(() => rooms[0]);
            }
            
            // If we have more rooms than time slots, take the first N rooms
            if (rooms.length > timeSlots.length) {
                return rooms.slice(0, timeSlots.length);
            }
            
            // If we have fewer rooms than time slots, repeat the last room
            const result = [...rooms];
            while (result.length < timeSlots.length) {
                result.push(rooms[rooms.length - 1] || 'TBA');
            }
            
            return result;
        }
        
        // Parse Excel time format like "Fr 13 - 16", "Tu 13 - 16 Th 14 - 16", or "Tu/Fr 09 - 12 Tu/Fr 13 - 15"
        function parseExcelTime(timeString) {
            if (!timeString) return [];
            
            const timeSlots = [];
            
            // Handle different patterns:
            // 1. "Tu/Fr 09 - 12 Tu/Fr 13 - 15" (multiple days same time, multiple time blocks)
            // 2. "Tu 13 - 16 Th 14 - 16" (different days different times)
            // 3. "Fr 13 - 16" (single day single time)
            
            // First, try to split by multiple consecutive spaces to separate different time blocks
            let timeBlocks = timeString.split(/\s{2,}/).filter(block => block.trim());
            
            // If no multiple spaces found, check if it contains separate day-time patterns
            if (timeBlocks.length <= 1) {
                // Look for patterns like "Tu 13 - 16 Th 14 - 16" (single spaces)
                const separateDayPattern = /([A-Za-z]{2})\s+(\d{1,2})\s*-\s*(\d{1,2})/g;
                const matches = [...timeString.matchAll(separateDayPattern)];
                
                if (matches.length > 1) {
                    // Multiple separate day-time pairs found
                    matches.forEach(match => {
                        const [, dayAbbr, startHour, endHour] = match;
                        const fullDay = dayMapping[dayAbbr];
                        if (fullDay) {
                            timeSlots.push({
                                Day: fullDay,
                                StartHour: parseInt(startHour),
                                EndHour: parseInt(endHour)
                            });
                        }
                    });
                    return timeSlots;
                } else {
                    // Single block
                    timeBlocks = [timeString];
                }
            }
            
            // Process each time block
            timeBlocks.forEach(block => {
                // Handle patterns like "Tu/Fr 09 - 12" (multiple days with same time)
                const dayTimeMatch = block.match(/([A-Za-z]{2}(?:\/[A-Za-z]{2})*)\s+(\d{1,2})\s*-\s*(\d{1,2})/);
                
                if (dayTimeMatch) {
                    const [, dayPart, startHour, endHour] = dayTimeMatch;
                    const days = dayPart.split('/'); // Split multiple days like "Tu/Fr"
                    
                    days.forEach(dayAbbr => {
                        const fullDay = dayMapping[dayAbbr.trim()];
                        if (fullDay) {
                            timeSlots.push({
                                Day: fullDay,
                                StartHour: parseInt(startHour),
                                EndHour: parseInt(endHour)
                            });
                        }
                    });
                }
            });
            
            return timeSlots;
        }
        
        // Sample lecture data with Excel-like time format (matching real Excel structure)
        const sampleLectures = [
            { Code: "ADA 403", Name: "Exploratory Data Analysis", Lecturer: "", Hours: "3", Section: "01", ExcelTime: "Fr 13 - 16", Room: "DB20" },
            { Code: "ADA 423", Name: "Statistical Inference Methods with Applications", Lecturer: "≈ûafak √ñzden", Hours: "3", Section: "01", ExcelTime: "Th 11 - 14", Room: "DB16" },
            { Code: "ARCH 101", Name: "Basics of Design", Lecturer: "G√∂khan Kƒ±nayoƒülu", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 13 - 15 Tu/Fr 09 - 12", Room: "E310-MTF E310-MTF" },
            { Code: "ARCH 111", Name: "Architectural Communication Techniques I", Lecturer: "Ba≈üak U√ßar Kƒ±rmƒ±zƒ±g√∂l", Hours: "3", Section: "01", ExcelTime: "Th 09 - 13", Room: "E310-MTF" },
            { Code: "ARCH 121", Name: "Introduction to Architecture", Lecturer: "Bilge ƒ∞mamoƒülu", Hours: "3", Section: "01", ExcelTime: "We 09 - 12", Room: "D026" },
            { Code: "ARCH 201", Name: "Architectural Design I", Lecturer: "Zuhal Acar Metin", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 09 - 12 Tu/Fr 13 - 15", Room: "E312-MTF E312-MTF" },
            { Code: "ARCH 301", Name: "Architectural Design III", Lecturer: "Azize Elif Yabacƒ±", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 09 - 12 Tu/Fr 13 - 15", Room: "E314-MTF E314-MTF" },
            { Code: "ARCH 301-O", Name: "Architectural Design III", Lecturer: "G√ºltekin Doruk Atay", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 13 - 15 Tu/Fr 09 - 12", Room: "E314-MTF E314-MTF" },
            { Code: "ARCH 381", Name: "Urban Design", Lecturer: "Seray T√ºrkay Co≈ükun", Hours: "3", Section: "01", ExcelTime: "Mo 09 - 13", Room: "D026" },
            { Code: "BA 305", Name: "Production and Operations Management", Lecturer: "Hakan B√ºt√ºner", Hours: "3", Section: "01", ExcelTime: "Mo 12 - 15 Th 17 - 18", Room: "G213 GB13-PC-L" },
            { Code: "CE 214", Name: "Introduction to Mechanics of Materials", Lecturer: "Rƒ±za Secer Orkun Keskin", Hours: "4", Section: "01", ExcelTime: "Tu 14 - 16 We 14 - 15 Fr 15 - 17", Room: "G101 DB102-MF-L DB102-MF-L" },
            { Code: "CE 331", Name: "Hydromechanics", Lecturer: "Aslƒ± Numanoƒülu Gen√ß", Hours: "4", Section: "01", ExcelTime: "We 15 - 16 Th 12 - 14 Fr 13 - 15", Room: "G101 DB102-MF-L DB102-MF-L" },
            { Code: "CMPE 113", Name: "Fundamentals of Programming I", Lecturer: "Semihanur Aktay Suba≈üƒ±", Hours: "3", Section: "01", ExcelTime: "Tu 15 - 17 We 14 - 16", Room: "DB14 A514-PC-L" },
            { Code: "ECON 101", Name: "Introduction to Economics", Lecturer: "G√ºnnur Ege Bilgin", Hours: "3", Section: "01", ExcelTime: "Tu 13 - 16 Th 14 - 16", Room: "G213 DB102" },
            { Code: "CITY 101-O", Name: "Introduction to City Planning", Lecturer: "Irmak Yavuz √ñzg√ºr, Baykan G√ºnay", Hours: "6", Section: "01", ExcelTime: "Tu/Fr 09 - 12 Tu/Fr 13 - 15", Room: "E315-MTF E315-MTF" }
        ];
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            initializeTimetable();
            loadLectures().then(() => {
                // Try to auto-load saved session after lectures are loaded
                if (!autoLoadSession()) {
                    console.log('No saved session found or failed to load, starting fresh');
                }
                // Setup auto-save functionality
                setupAutoSave();
            });
            setupSearchFunctionality();
        });
        
        // Initialize empty timetable
        function initializeTimetable() {
            const timetableGrid = document.getElementById('timetableGrid');
            
            // Create CSS Grid layout
            let gridHTML = '';
            
            // Headers
            gridHTML += '<div class="timetable-header">Time</div>';
            gridHTML += '<div class="timetable-header">Monday</div>';
            gridHTML += '<div class="timetable-header">Tuesday</div>';
            gridHTML += '<div class="timetable-header">Wednesday</div>';
            gridHTML += '<div class="timetable-header">Thursday</div>';
            gridHTML += '<div class="timetable-header">Friday</div>';
            
            // Time slots and cells
            timeHours.forEach(hour => {
                const nextHour = hour + 1;
                const timeLabel = `${hour.toString().padStart(2, '0')}:00 - ${nextHour.toString().padStart(2, '0')}:00`;
                
                // Time slot
                gridHTML += `<div class="time-slot">${timeLabel}</div>`;
                
                // Day cells with click handlers
                days.forEach(day => {
                    gridHTML += `<div class="timetable-cell" id="cell_${day}_${hour}" onclick="toggleTimeSlotLock('${day}', ${hour})"></div>`;
                });
            });
            
            timetableGrid.innerHTML = gridHTML;
            console.log('Modern timetable initialized with CSS Grid and click handlers');
        }
        
        // Load lectures from API or use sample data
        async function loadLectures() {
            try {
                const response = await fetch('http://localhost:5000/api/lectures');
                if (response.ok) {
                    const rawLectures = await response.json();
                    allLectures = processLectures(rawLectures);
                } else {
                    throw new Error('API not available');
                }
            } catch (error) {
                console.log('Using sample data - API not available');
                allLectures = processLectures(sampleLectures);
            }
            
            console.log('Processed lectures:', allLectures);
            document.getElementById('loadingMessage').style.display = 'none';
            displayLectures(allLectures);
        }
        
        // Setup search functionality
        function setupSearchFunctionality() {
            const searchInput = document.getElementById('lectureSearch');
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase().normalize('NFD');
                const filteredLectures = allLectures.filter(lecture => 
                    lecture.Code.toLowerCase().normalize('NFD').includes(searchTerm) ||
                    lecture.Name.toLowerCase().normalize('NFD').includes(searchTerm) ||
                    (lecture.Lecturer && lecture.Lecturer.toLowerCase().normalize('NFD').includes(searchTerm))
                );
                displayLectures(filteredLectures);
            });
        }
        
        // Display lectures in the list
        function displayLectures(lectures) {
            const resultsContainer = document.getElementById('lectureResults');
            
            if (lectures.length === 0) {
                resultsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No lectures found.</p>';
                return;
            }
            
            // Group lectures by code and name only (merge all sections)
            const lecturesByCode = {};
            lectures.forEach(lecture => {
                const key = lecture.Code; // Group by code only
                if (!lecturesByCode[key]) {
                    lecturesByCode[key] = {
                        Code: lecture.Code,
                        Name: lecture.Name,
                        Hours: lecture.Hours,
                        sections: []
                    };
                }
                
                // Find or create section within this lecture
                let existingSection = lecturesByCode[key].sections.find(s => s.Section === lecture.Section);
                if (!existingSection) {
                    existingSection = {
                        Section: lecture.Section,
                        Lecturer: lecture.Lecturer,
                        ExcelTime: lecture.ExcelTime,
                        timeSlots: []
                    };
                    lecturesByCode[key].sections.push(existingSection);
                }
                
                // Add time slot to section
                existingSection.timeSlots.push({
                    Day: lecture.Day,
                    StartHour: lecture.StartHour,
                    EndHour: lecture.EndHour
                });
            });
            
            resultsContainer.innerHTML = Object.values(lecturesByCode).map(lecture => `
                <div class="lecture-item">
                    <label style="display: flex; align-items: flex-start; cursor: pointer;">
                        <input type="checkbox" value="${lecture.Code}" onchange="toggleLectureSelection('${lecture.Code}')" 
                               style="margin-right: 15px; margin-top: 5px; transform: scale(1.3);"
                               ${selectedLectures.some(selected => selected.Code === lecture.Code) ? 'checked' : ''}>
                        <div style="flex: 1;">
                            <div><strong style="color: #007bff; font-size: 16px;">${lecture.Code}</strong> - ${lecture.Name}</div>
                            <div style="color: #666; margin: 8px 0;">Hours: ${lecture.Hours}</div>
                            <div style="margin-top: 10px;">
                                <strong style="color: #333; font-size: 14px;">Available Sections:</strong>
                                <div style="margin-top: 5px;">
                                    ${lecture.sections.map(section => `
                                        <div style="background: #f8f9fa; padding: 8px; margin: 4px 0; border-radius: 5px; border-left: 3px solid #007bff;">
                                            <span style="font-weight: bold;">Section ${section.Section}</span> - ${section.Lecturer}<br>
                                            <span style="color: #666; font-size: 12px;">Excel Time: ${section.ExcelTime}</span><br>
                                            ${section.timeSlots.map(slot => 
                                                `<span style="color: #28a745; font-weight: bold; display: inline-block; margin-right: 10px;">${slot.Day} ${slot.StartHour}:00-${slot.EndHour}:00</span>`
                                            ).join('')}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    </label>
                </div>
            `).join('');
        }
        
        // Toggle lecture selection
        function toggleLectureSelection(lectureCode) {
            const lecturesWithCode = allLectures.filter(l => l.Code === lectureCode);
            const existingIndex = selectedLectures.findIndex(l => l.Code === lectureCode);
            
            if (existingIndex > -1) {
                selectedLectures.splice(existingIndex, 1);
                // Remove both lecturer and section preferences when lecture is deselected
                delete lecturerPreferences[lectureCode];
                delete sectionPreferences[lectureCode];
                // Remove color assignment when lecture is deselected
                delete lectureColors[lectureCode];
            } else {
                // Add the first occurrence (we'll show all sections in combinations)
                selectedLectures.push(lecturesWithCode[0]);
                // Assign a random color to the newly selected lecture
                assignLectureColor(lectureCode);
            }
            
            updateSelectedLecturesDisplay();
            generateTimetableCombinations();
            
            // Auto-save session after lecture selection changes
            autoSaveSession();
        }
        
        // Update lecturer preference for a specific lecture
        function updateLecturerPreference(lectureCode, preferredLecturer) {
            console.log(`Updating lecturer preference for ${lectureCode} to ${preferredLecturer}`);
            
            if (preferredLecturer === 'any') {
                delete lecturerPreferences[lectureCode];
            } else {
                lecturerPreferences[lectureCode] = preferredLecturer;
            }
            
            // Regenerate combinations if we have selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Open lecture filter popup
        function openLectureFilterPopup(lectureCode) {
            const lecture = selectedLectures.find(l => l.Code === lectureCode);
            if (!lecture) return;
            
            // Get all sections for this lecture with their details
            const sections = {};
            allLectures.forEach(l => {
                if (l.Code === lectureCode) {
                    if (!sections[l.Section]) {
                        sections[l.Section] = {
                            section: l.Section,
                            lecturer: l.Lecturer || 'TBA',
                            excelTime: l.ExcelTime,
                            timeSlots: []
                        };
                    }
                    sections[l.Section].timeSlots.push({
                        day: l.Day,
                        startHour: l.StartHour,
                        endHour: l.EndHour
                    });
                }
            });
            
            const sectionList = Object.values(sections);
            const allLecturers = [...new Set(sectionList.map(s => s.lecturer).filter(l => l && l !== 'TBA'))];
            
            const currentLecturerPref = lecturerPreferences[lectureCode] || [];
            const currentSectionPref = sectionPreferences[lectureCode] || [];
            
            // Create popup HTML
            const popupHTML = `
                <div id="lectureFilterOverlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center;" onclick="closeLectureFilterPopup()">
                    <div style="background: white; border-radius: 12px; padding: 24px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3);" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0; color: #333;">üéØ Filter: ${lectureCode} - ${lecture.Name}</h3>
                            <button onclick="closeLectureFilterPopup()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">√ó</button>
                        </div>
                        
                        <!-- Lecturer Filter Section -->
                        <div style="margin-bottom: 24px;">
                            <h4 style="margin: 0 0 12px 0; color: #495057;">Select Lecturers:</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;">
                                ${allLecturers.map(lecturer => `
                                    <label style="display: flex; align-items: center; background: #f8f9fa; padding: 8px 12px; border-radius: 20px; cursor: pointer; transition: all 0.2s; border: 1px solid #dee2e6;" 
                                           onmouseover="this.style.backgroundColor='#e9ecef'" onmouseout="this.style.backgroundColor='#f8f9fa'">
                                        <input type="checkbox" value="${lecturer}" ${currentLecturerPref.includes(lecturer) ? 'checked' : ''} 
                                               onchange="toggleLecturerFilter('${lectureCode}', '${lecturer}', this.checked)" 
                                               style="margin-right: 8px;">
                                        <span style="font-size: 13px;">${lecturer}</span>
                                    </label>
                                `).join('')}
                            </div>
                            <button onclick="selectAllLecturers('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">Select All</button>
                            <button onclick="clearAllLecturers('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear All</button>
                        </div>
                        
                        <!-- Section Filter Section -->
                        <div style="margin-bottom: 24px;">
                            <h4 style="margin: 0 0 12px 0; color: #495057;">Select Sections:</h4>
                            <div style="display: grid; gap: 12px;">
                                ${sectionList.map(section => `
                                    <label style="display: flex; align-items: flex-start; background: #f8f9fa; padding: 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid #dee2e6;" 
                                           onmouseover="this.style.backgroundColor='#e9ecef'" onmouseout="this.style.backgroundColor='#f8f9fa'">
                                        <input type="checkbox" value="${section.section}" ${currentSectionPref.includes(section.section) ? 'checked' : ''} 
                                               onchange="toggleSectionFilter('${lectureCode}', '${section.section}', this.checked)" 
                                               style="margin-right: 12px; margin-top: 2px;">
                                        <div style="flex: 1;">
                                            <div style="font-weight: bold; color: #007bff; margin-bottom: 4px;">Section ${section.section}</div>
                                            <div style="font-size: 13px; color: #666; margin-bottom: 4px;">Lecturer: ${section.lecturer}</div>
                                            <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Schedule: ${section.excelTime}</div>
                                            <div style="font-size: 11px; color: #28a745;">
                                                ${section.timeSlots.map(slot => `${slot.day} ${slot.startHour}:00-${slot.endHour}:00`).join(' | ')}
                                            </div>
                                        </div>
                                    </label>
                                `).join('')}
                            </div>
                            <div style="margin-top: 12px;">
                                <button onclick="selectAllSections('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">Select All</button>
                                <button onclick="clearAllSections('${lectureCode}')" style="font-size: 12px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear All</button>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; justify-content: flex-end; gap: 12px; padding-top: 12px; border-top: 1px solid #dee2e6;">
                            <button onclick="clearAllFilters('${lectureCode}')" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;">Clear All Filters</button>
                            <button onclick="applyFiltersAndClose('${lectureCode}')" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">Apply Filters</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add popup to DOM
            document.body.insertAdjacentHTML('beforeend', popupHTML);
        }
        
        // Close lecture filter popup
        function closeLectureFilterPopup() {
            const overlay = document.getElementById('lectureFilterOverlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Toggle lecturer filter
        function toggleLecturerFilter(lectureCode, lecturer, isChecked) {
            if (!lecturerPreferences[lectureCode]) {
                lecturerPreferences[lectureCode] = [];
            }
            
            if (isChecked) {
                if (!lecturerPreferences[lectureCode].includes(lecturer)) {
                    lecturerPreferences[lectureCode].push(lecturer);
                }
            } else {
                lecturerPreferences[lectureCode] = lecturerPreferences[lectureCode].filter(l => l !== lecturer);
                if (lecturerPreferences[lectureCode].length === 0) {
                    delete lecturerPreferences[lectureCode];
                }
            }
        }
        
        // Toggle section filter
        function toggleSectionFilter(lectureCode, section, isChecked) {
            if (!sectionPreferences[lectureCode]) {
                sectionPreferences[lectureCode] = [];
            }
            
            if (isChecked) {
                if (!sectionPreferences[lectureCode].includes(section)) {
                    sectionPreferences[lectureCode].push(section);
                }
            } else {
                sectionPreferences[lectureCode] = sectionPreferences[lectureCode].filter(s => s !== section);
                if (sectionPreferences[lectureCode].length === 0) {
                    delete sectionPreferences[lectureCode];
                }
            }
        }
        
        // Select all lecturers for a lecture
        function selectAllLecturers(lectureCode) {
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            const lecturerCheckboxes = Array.from(checkboxes).filter(cb => {
                return allLectures.some(l => l.Code === lectureCode && l.Lecturer === cb.value);
            });
            
            lecturerPreferences[lectureCode] = [];
            lecturerCheckboxes.forEach(cb => {
                cb.checked = true;
                if (!lecturerPreferences[lectureCode].includes(cb.value)) {
                    lecturerPreferences[lectureCode].push(cb.value);
                }
            });
        }
        
        // Clear all lecturers for a lecture
        function clearAllLecturers(lectureCode) {
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            const lecturerCheckboxes = Array.from(checkboxes).filter(cb => {
                return allLectures.some(l => l.Code === lectureCode && l.Lecturer === cb.value);
            });
            
            lecturerCheckboxes.forEach(cb => cb.checked = false);
            delete lecturerPreferences[lectureCode];
        }
        
        // Select all sections for a lecture
        function selectAllSections(lectureCode) {
            const sections = [...new Set(allLectures.filter(l => l.Code === lectureCode).map(l => l.Section))];
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            
            sectionPreferences[lectureCode] = [];
            checkboxes.forEach(cb => {
                if (sections.includes(cb.value)) {
                    cb.checked = true;
                    if (!sectionPreferences[lectureCode].includes(cb.value)) {
                        sectionPreferences[lectureCode].push(cb.value);
                    }
                }
            });
        }
        
        // Clear all sections for a lecture
        function clearAllSections(lectureCode) {
            const sections = [...new Set(allLectures.filter(l => l.Code === lectureCode).map(l => l.Section))];
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"][value*=""]');
            
            checkboxes.forEach(cb => {
                if (sections.includes(cb.value)) {
                    cb.checked = false;
                }
            });
            delete sectionPreferences[lectureCode];
        }
        
        // Clear all filters for a lecture
        function clearAllFilters(lectureCode) {
            delete lecturerPreferences[lectureCode];
            delete sectionPreferences[lectureCode];
            
            const checkboxes = document.querySelectorAll('#lectureFilterOverlay input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
        }
        
        // Apply filters and close popup
        function applyFiltersAndClose(lectureCode) {
            closeLectureFilterPopup();
            updateSelectedLecturesDisplay();
            generateTimetableCombinations();
        }
        
        // Alternative Course Management Functions
        
        // Create a new alternative course group
        function createAlternativeGroup(courseCode1, courseCode2) {
            const groupId = `alt_group_${alternativeGroupCounter++}`;
            
            // Remove courses from existing groups first
            removeFromAlternativeGroup(courseCode1);
            removeFromAlternativeGroup(courseCode2);
            
            // Create new group
            alternativeCourseGroups[groupId] = [courseCode1, courseCode2];
            courseToAlternativeGroup[courseCode1] = groupId;
            courseToAlternativeGroup[courseCode2] = groupId;
            
            console.log(`Created alternative group ${groupId}:`, [courseCode1, courseCode2]);
            updateSelectedLecturesDisplay();
            generateTimetableCombinations();
        }
        
        // Remove a course from its alternative group
        function removeFromAlternativeGroup(courseCode) {
            const groupId = courseToAlternativeGroup[courseCode];
            if (groupId && alternativeCourseGroups[groupId]) {
                const group = alternativeCourseGroups[groupId];
                const index = group.indexOf(courseCode);
                if (index > -1) {
                    group.splice(index, 1);
                }
                
                // Remove course mapping
                delete courseToAlternativeGroup[courseCode];
                
                // If group has less than 2 courses, dissolve it
                if (group.length < 2) {
                    group.forEach(code => delete courseToAlternativeGroup[code]);
                    delete alternativeCourseGroups[groupId];
                }
                
                console.log(`Removed ${courseCode} from alternative group ${groupId}`);
                updateSelectedLecturesDisplay();
                generateTimetableCombinations();
            }
        }
        
        // Get all courses that can be alternatives to a given course
        function getAvailableAlternatives(courseCode) {
            return selectedLectures
                .filter(lecture => lecture.Code !== courseCode && !courseToAlternativeGroup[lecture.Code])
                .map(lecture => lecture.Code);
        }
        
        // Check if a course is part of an alternative group
        function isInAlternativeGroup(courseCode) {
            return courseToAlternativeGroup[courseCode] !== undefined;
        }
        
        // Get alternative group info for a course
        function getAlternativeGroupInfo(courseCode) {
            const groupId = courseToAlternativeGroup[courseCode];
            if (groupId && alternativeCourseGroups[groupId]) {
                return {
                    groupId,
                    alternatives: alternativeCourseGroups[groupId].filter(code => code !== courseCode)
                };
            }
            return null;
        }
        
        // Update selected lectures display
        function updateSelectedLecturesDisplay() {
            const container = document.getElementById('selectedLectures');
            
            if (selectedLectures.length === 0) {
                container.innerHTML = '<p style="color: #666; margin: 0;">No lectures selected yet.</p>';
                return;
            }
            
            container.innerHTML = selectedLectures.map(lecture => {
                // Get all available lecturers for this lecture code
                const availableLecturers = [...new Set(
                    allLectures
                        .filter(l => l.Code === lecture.Code)
                        .map(l => l.Lecturer)
                        .filter(l => l && l.trim() !== '')
                )];
                
                // Get all available sections for this lecture code
                const availableSections = [...new Set(
                    allLectures
                        .filter(l => l.Code === lecture.Code)
                        .map(l => l.Section)
                )];
                
                const currentLecturerPref = lecturerPreferences[lecture.Code];
                const currentSectionPref = sectionPreferences[lecture.Code];
                
                // Get the assigned color for this lecture
                const lectureColor = getLectureColor(lecture.Code);
                
                // Create filter summary
                let filterSummary = [];
                if (currentLecturerPref && currentLecturerPref.length > 0) {
                    filterSummary.push(`Lecturers: ${currentLecturerPref.join(', ')}`);
                }
                if (currentSectionPref && currentSectionPref.length > 0) {
                    filterSummary.push(`Sections: ${currentSectionPref.join(', ')}`);
                }
                
                // Get alternative course information
                const alternativeInfo = getAlternativeGroupInfo(lecture.Code);
                const availableAlternatives = getAvailableAlternatives(lecture.Code);
                
                return `
                <div class="selected-lecture-tag" style="display: flex; flex-direction: column; gap: 8px; padding: 12px; margin: 8px 0; background: ${lectureColor.bg}; color: ${lectureColor.text}; border-radius: 8px; border: 1px solid rgba(255,255,255,0.3); cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.15);" 
                     onclick="openLectureFilterPopup('${lecture.Code}')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.25)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)';">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: bold;">${lecture.Code} - ${lecture.Name}</span>
                        <div style="display: flex; gap: 4px;">
                            <button onclick="event.stopPropagation(); showAlternativePopup('${lecture.Code}')" 
                                    style="background: rgba(255,255,255,0.2); color: ${lectureColor.text}; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;" 
                                    title="Manage alternative courses">üîÑ</button>
                            <button onclick="event.stopPropagation(); toggleLectureSelection('${lecture.Code}')" class="remove-btn" 
                                    style="background: rgba(255,255,255,0.2); color: ${lectureColor.text}; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-weight: bold;">√ó</button>
                        </div>
                    </div>
                    
                    ${alternativeInfo ? `
                    <div style="font-size: 11px; color: ${lectureColor.text}; background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);">
                        üîÑ Alternative to: ${alternativeInfo.alternatives.join(', ')}
                    </div>
                    ` : ''}
                    
                    ${filterSummary.length > 0 ? `
                    <div style="font-size: 11px; color: ${lectureColor.text}; background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);">
                        üì¶ Filtered: ${filterSummary.join(' | ')}
                    </div>
                    ` : `
                    <div style="font-size: 11px; color: ${lectureColor.text}; opacity: 0.9;">
                        Click to filter sections/lecturers ‚Ä¢ ${availableSections.length} sections ‚Ä¢ ${availableLecturers.length} lecturers
                    </div>
                    `}
                </div>
                `;
            }).join('');
        }
        
        // Show alternative course popup
        function showAlternativePopup(courseCode) {
            const alternativeInfo = getAlternativeGroupInfo(courseCode);
            const availableAlternatives = getAvailableAlternatives(courseCode);
            
            const popupHTML = `
                <div id="alternativePopupOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">
                    <div style="background: white; padding: 20px; border-radius: 12px; max-width: 500px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                        <h3 style="margin: 0 0 15px 0; color: #333;">Alternative Courses for ${courseCode}</h3>
                        
                        ${alternativeInfo ? `
                            <div style="background: #e8f5e8; padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #4caf50;">
                                <strong>üîÑ Currently paired with:</strong> ${alternativeInfo.alternatives.join(', ')}
                                <div style="margin-top: 8px;">
                                    <button onclick="removeFromAlternativeGroup('${courseCode}'); closeAlternativePopup();" 
                                            style="background: #ff5722; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                        Remove from alternative group
                                    </button>
                                </div>
                            </div>
                        ` : `
                            <div style="background: #fff3e0; padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #ff9800;">
                                <strong>‚ÑπÔ∏è Not in any alternative group</strong>
                                <p style="margin: 5px 0 0 0; font-size: 14px; color: #666;">You can create an alternative group by selecting another course below.</p>
                            </div>
                        `}
                        
                        ${availableAlternatives.length > 0 ? `
                            <div style="margin-bottom: 15px;">
                                <strong>Available alternatives:</strong>
                                <div style="margin-top: 8px; display: flex; flex-direction: column; gap: 6px;">
                                    ${availableAlternatives.map(altCode => `
                                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #f5f5f5; border-radius: 6px;">
                                            <span>${altCode}</span>
                                            <button onclick="createAlternativeGroup('${courseCode}', '${altCode}'); closeAlternativePopup();" 
                                                    style="background: #4caf50; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                                ${alternativeInfo ? 'Switch to this alternative' : 'Create alternative group'}
                                            </button>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : `
                            <div style="background: #ffebee; padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #f44336;">
                                <strong>‚ö†Ô∏è No available alternatives</strong>
                                <p style="margin: 5px 0 0 0; font-size: 14px; color: #666;">All other selected courses are already in alternative groups.</p>
                            </div>
                        `}
                        
                        <div style="text-align: right; margin-top: 15px;">
                            <button onclick="closeAlternativePopup()" style="background: #2196f3; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                                Done
                            </button>
                        </div>
                        
                        <div style="margin-top: 15px; padding: 12px; background: #f0f8ff; border-radius: 6px; border: 1px solid #2196f3;">
                            <strong>üí° How Alternative Courses Work:</strong>
                            <ul style="margin: 5px 0 0 0; padding-left: 15px; font-size: 13px; color: #666;">
                                <li>Only one course from each alternative group will appear in any timetable combination</li>
                                <li>This helps when you need to choose between similar courses</li>
                                <li>Alternative groups allow more flexible scheduling options</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', popupHTML);
        }
        
        // Close alternative popup
        function closeAlternativePopup() {
            const overlay = document.getElementById('alternativePopupOverlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Generate all possible timetable combinations
        function generateTimetableCombinations() {
            const combinationsContainer = document.getElementById('timetableCombinations');
            const container = document.getElementById('combinationsContainer');
            const timetableControls = document.getElementById('timetableControls');
            
            if (selectedLectures.length === 0) {
                combinationsContainer.style.display = 'none';
                timetableControls.style.display = 'none';
                const exportControls = document.getElementById('exportControls');
                if (exportControls) {
                    exportControls.style.display = 'none';
                }
                validCombinations = [];
                clearTimetable();
                return;
            }
            
            combinationsContainer.style.display = 'block';
            
            // Show export controls
            const exportControls = document.getElementById('exportControls');
            if (exportControls) {
                exportControls.style.display = 'block';
            }
            
            // Group selected lectures by alternative groups
            const alternativeGroups = {};
            const independentLectures = [];
            
            selectedLectures.forEach(selected => {
                const groupId = courseToAlternativeGroup[selected.Code];
                if (groupId) {
                    if (!alternativeGroups[groupId]) {
                        alternativeGroups[groupId] = [];
                    }
                    alternativeGroups[groupId].push(selected);
                } else {
                    independentLectures.push(selected);
                }
            });
            
            // Create lecture options for combination generation
            // For alternative groups, create separate option sets for each course in the group
            const lectureOptionSets = [];
            
            // Add independent lectures (not in alternative groups)
            independentLectures.forEach(selected => {
                lectureOptionSets.push([selected]);
            });
            
            // Add alternative groups (each group becomes one option set with multiple courses)
            Object.values(alternativeGroups).forEach(groupLectures => {
                lectureOptionSets.push(groupLectures);
            });
            
            // Get all sections for each lecture option set, filtered by preferences
            const processedLectureOptions = lectureOptionSets.map(lectureSet => {
                return lectureSet.map(selected => {
                    const sectionsForCode = {};
                    allLectures.forEach(lecture => {
                        if (lecture.Code === selected.Code) {
                            // Check lecturer preference filter
                            const preferredLecturers = lecturerPreferences[selected.Code];
                            if (preferredLecturers && preferredLecturers.length > 0) {
                                if (!preferredLecturers.includes(lecture.Lecturer)) {
                                    return;
                                }
                            }
                            
                            // Check section preference filter
                            const preferredSections = sectionPreferences[selected.Code];
                            if (preferredSections && preferredSections.length > 0) {
                                if (!preferredSections.includes(lecture.Section)) {
                                    return;
                                }
                            }
                            
                            const sectionKey = lecture.Section;
                            if (!sectionsForCode[sectionKey]) {
                                sectionsForCode[sectionKey] = [];
                            }
                            sectionsForCode[sectionKey].push(lecture);
                        }
                    });
                    
                    const sectionsArray = Object.values(sectionsForCode);
                    return { courseCode: selected.Code, sections: sectionsArray };
                });
            });
            
            // Check if any processed lecture options are empty (no valid sections)
            const emptyOptions = processedLectureOptions.findIndex(optionSet => 
                optionSet.every(courseOption => courseOption.sections.length === 0)
            );
            
            if (emptyOptions !== -1) {
                container.innerHTML = `<p style="color: #dc3545; text-align: center; padding: 20px;">No sections available for some selected courses with current filters.<br>
                    <small>Please adjust your lecturer or section preferences and try again.</small></p>`;
                timetableControls.style.display = 'none';
                clearTimetable();
                return;
            }
            
            // Generate combinations respecting alternative course groups
            const allCombinations = generateAlternativeCombinations(processedLectureOptions);
            
            // Filter combinations based on all validation criteria (conflicts, empty days, locked slots)
            validCombinations = filterValidCombinations(allCombinations);
            
            if (validCombinations.length === 0) {
                const totalGenerated = allCombinations.length;
                const conflictFiltered = allCombinations.filter(c => countTimeConflicts(c) > maxAllowedConflicts).length;
                const emptyDaysFiltered = allCombinations.filter(c => countEmptyDays(c) < minRequiredEmptyDays).length;
                const lockedSlotsFiltered = allCombinations.filter(c => hasLockedTimeSlotConflicts(c)).length;
                
                let filterMessage = `No valid combinations found. Generated ${totalGenerated} total combinations, but all were filtered out:`;
                if (conflictFiltered > 0) filterMessage += `<br>‚Ä¢ ${conflictFiltered} had too many conflicts (>${maxAllowedConflicts})`;
                if (emptyDaysFiltered > 0) filterMessage += `<br>‚Ä¢ ${emptyDaysFiltered} had too few empty days (<${minRequiredEmptyDays})`;
                if (lockedSlotsFiltered > 0) filterMessage += `<br>‚Ä¢ ${lockedSlotsFiltered} conflicted with locked time slots`;
                filterMessage += `<br><br>Try adjusting your filters or lecture selections.`;
                
                container.innerHTML = `<p style="color: #dc3545; text-align: center; padding: 20px; line-height: 1.6;">${filterMessage}</p>`;
                timetableControls.style.display = 'none';
                clearTimetable();
                return;
            }
            
            // Show timetable controls
            timetableControls.style.display = 'block';
            populateCombinationSelector();
            
            // Display valid combinations list (excluding deleted ones)
            container.innerHTML = validCombinations
                .map((combination, index) => ({ combination, index }))
                .filter(item => !deletedCombinations.has(item.index))
                .map(item => {
                    const { combination, index } = item;
                    const conflictCount = countTimeConflicts(combination);
                    const emptyDaysCount = countEmptyDays(combination);
                    
                    const conflictBadge = conflictCount > 0 ? 
                        `<span style="background: #ffc107; color: #856404; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 5px;">${conflictCount} conflict${conflictCount > 1 ? 's' : ''}</span>` : 
                        '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 5px;">No conflicts</span>';
                    
                    const emptyDaysBadge = emptyDaysCount > 0 ? 
                        `<span style="background: #17a2b8; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 5px;">${emptyDaysCount} empty day${emptyDaysCount > 1 ? 's' : ''}</span>` : 
                        '<span style="background: #6f42c1; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 5px;">All days occupied</span>';
                    
                    const borderColor = conflictCount > 0 ? '#ffc107' : '#28a745';
                    const backgroundColor = 'white';
                    const isBookmarked = bookmarkedCombinations.has(index);
                    const bookmarkIcon = isBookmarked ? '‚≠ê' : '';
                    
                    return `
                    <div style="margin-bottom: 20px; padding: 15px; border: 2px solid ${borderColor}; border-radius: 10px; background: ${backgroundColor};">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                            <h4 style="margin: 0; color: #007bff; display: flex; align-items: center;">${bookmarkIcon} Combination ${index + 1}${conflictBadge}</h4>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <button onclick="selectCombinationFromList(${index})" style="padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">View</button>
                                <button onclick="toggleBookmarkFromList(${index})" style="padding: 4px 8px; background: ${isBookmarked ? '#6c757d' : '#ffc107'}; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">${isBookmarked ? 'Unbookmark' : 'Bookmark'}</button>
                                <button onclick="deleteCombinationFromList(${index})" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Delete</button>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; color: #666;">
                                    <input type="checkbox" class="combination-export-checkbox" data-index="${index}" onchange="toggleCombinationSelection(${index})" style="cursor: pointer; transform: scale(1.2);">
                                    Export
                                </label>
                            </div>
                        </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
                        ${combination.map(lectureGroup => {
                            const firstLecture = lectureGroup[0];
                            return `
                                <div style="padding: 10px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #28a745;">
                                    <div style="font-weight: bold; color: #007bff;">${firstLecture.Code} - Section ${firstLecture.Section}</div>
                                    <div style="color: #666; font-size: 14px;">${firstLecture.Name}</div>
                                    <div style="color: #333; margin-top: 5px;">${firstLecture.Lecturer}</div>
                                    <div style="color: #666; font-size: 12px; margin-top: 3px;">Excel: ${firstLecture.ExcelTime}</div>
                                    ${lectureGroup.map(lecture => 
                                        `<div style="margin-top: 3px;">
                                            <div style="color: #28a745; font-weight: bold; font-size: 12px;">${lecture.Day} ${lecture.StartHour}:00-${lecture.EndHour}:00</div>
                                            <div style="color: #6c757d; font-size: 11px; margin-left: 10px;">Room: ${lecture.Room || 'TBA'}</div>
                                        </div>`
                                    ).join('')}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <button onclick="selectCombinationInDropdown(${index})" style="margin-top: 15px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Show in Timetable
                    </button>
                </div>
                `;
            }).join('');
            
            // Clear previous export selections and update controls
            selectedCombinationsForExport.clear();
            updateExportControls();
            
            // Auto-select first combination if available
            if (validCombinations.length > 0) {
                currentCombinationIndex = 0;
                displayCombinationInTimetable();
            }
        }
        
        // Populate the combination selector dropdown
        function populateCombinationSelector() {
            const selector = document.getElementById('combinationSelector');
            const info = document.getElementById('combinationInfo');
            
            // Filter out deleted combinations
            const activeCombinations = validCombinations
                .map((combination, index) => ({ combination, originalIndex: index }))
                .filter(item => !deletedCombinations.has(item.originalIndex));
            
            const totalCount = activeCombinations.length;
            const deletedCount = deletedCombinations.size;
            const bookmarkedCount = bookmarkedCombinations.size;
            
            // Separate bookmarked and non-bookmarked combinations
            const bookmarkedItems = activeCombinations.filter(item => bookmarkedCombinations.has(item.originalIndex));
            const regularItems = activeCombinations.filter(item => !bookmarkedCombinations.has(item.originalIndex));
            
            // Build options with bookmarked combinations first
            let options = '<option value="">Select a combination...</option>';
            
            // Add bookmarked combinations first (with star indicator)
            bookmarkedItems.forEach(item => {
                const conflictCount = countTimeConflicts(item.combination);
                const emptyDaysCount = countEmptyDays(item.combination);
                const conflictText = conflictCount > 0 ? ` (${conflictCount} conflicts)` : '';
                const emptyDaysText = emptyDaysCount > 0 ? ` (${emptyDaysCount} empty days)` : '';
                options += `<option value="${item.originalIndex}">‚≠ê Combination ${item.originalIndex + 1}${conflictText}${emptyDaysText}</option>`;
            });
            
            // Add separator if we have bookmarked combinations
            if (bookmarkedItems.length > 0 && regularItems.length > 0) {
                options += '<option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>';
            }
            
            // Add regular combinations
            regularItems.forEach(item => {
                const conflictCount = countTimeConflicts(item.combination);
                const emptyDaysCount = countEmptyDays(item.combination);
                const conflictText = conflictCount > 0 ? ` (${conflictCount} conflicts)` : '';
                const emptyDaysText = emptyDaysCount > 0 ? ` (${emptyDaysCount} empty days)` : '';
                options += `<option value="${item.originalIndex}">Combination ${item.originalIndex + 1}${conflictText}${emptyDaysText}</option>`;
            });
            
            selector.innerHTML = options;
            
            // Update info text
            let infoText = `${totalCount} valid combination(s) found`;
            if (deletedCount > 0) {
                infoText += `, ${deletedCount} deleted`;
            }
            if (bookmarkedCount > 0) {
                infoText += `, ${bookmarkedCount} bookmarked`;
            }
            info.textContent = infoText;
            
            // Update bookmarked combinations display
            updateBookmarkedCombinationsDisplay();
            
            // Update combination action buttons visibility
            updateCombinationActionButtons();
        }
        
        // Select combination from dropdown
        function selectCombinationInDropdown(index) {
            const selector = document.getElementById('combinationSelector');
            selector.value = index;
            currentCombinationIndex = index;
            displayCombinationInTimetable();
        }
        
        // Update combination action buttons visibility
        function updateCombinationActionButtons() {
            const selector = document.getElementById('combinationSelector');
            const bookmarkBtn = document.getElementById('bookmarkBtn');
            const deleteBtn = document.getElementById('deleteBtn');
            
            const selectedIndex = parseInt(selector.value);
            const hasValidSelection = !isNaN(selectedIndex) && selectedIndex >= 0;
            
            if (hasValidSelection && !deletedCombinations.has(selectedIndex)) {
                bookmarkBtn.style.display = 'inline-block';
                deleteBtn.style.display = 'inline-block';
                
                // Update bookmark button text based on current state
                if (bookmarkedCombinations.has(selectedIndex)) {
                    bookmarkBtn.innerHTML = '‚≠ê Unbookmark';
                    bookmarkBtn.style.background = '#6c757d';
                    bookmarkBtn.title = 'Remove bookmark from this combination';
                } else {
                    bookmarkBtn.innerHTML = '‚≠ê Bookmark';
                    bookmarkBtn.style.background = '#ffc107';
                    bookmarkBtn.title = 'Bookmark this combination';
                }
            } else {
                bookmarkBtn.style.display = 'none';
                deleteBtn.style.display = 'none';
            }
        }
        
        // Toggle bookmark status of current combination
        function toggleBookmarkCombination() {
            const selector = document.getElementById('combinationSelector');
            const selectedIndex = parseInt(selector.value);
            
            if (isNaN(selectedIndex) || selectedIndex < 0 || deletedCombinations.has(selectedIndex)) {
                return;
            }
            
            if (bookmarkedCombinations.has(selectedIndex)) {
                bookmarkedCombinations.delete(selectedIndex);
                console.log(`Removed bookmark from combination ${selectedIndex + 1}`);
            } else {
                bookmarkedCombinations.add(selectedIndex);
                console.log(`Bookmarked combination ${selectedIndex + 1}`);
            }
            
            // Refresh the combination selector to show updated order
            populateCombinationSelector();
            
            // Restore the current selection
            selector.value = selectedIndex;
            updateCombinationActionButtons();
            
            // Auto-save session
            autoSaveSession();
        }
        
        // Delete current combination
        function deleteCombination() {
            const selector = document.getElementById('combinationSelector');
            const selectedIndex = parseInt(selector.value);
            
            if (isNaN(selectedIndex) || selectedIndex < 0 || deletedCombinations.has(selectedIndex)) {
                return;
            }
            
            const confirmDelete = confirm(`Are you sure you want to delete Combination ${selectedIndex + 1}? This action cannot be undone.`);
            
            if (!confirmDelete) {
                return;
            }
            
            // Add to deleted combinations
            deletedCombinations.add(selectedIndex);
            
            // Remove from bookmarked if it was bookmarked
            bookmarkedCombinations.delete(selectedIndex);
            
            // Remove from export selections if it was selected for export
            selectedCombinationsForExport.delete(selectedIndex);
            
            console.log(`Deleted combination ${selectedIndex + 1}`);
            
            // Clear current timetable if it was showing the deleted combination
            if (currentCombinationIndex === selectedIndex) {
                currentCombinationIndex = 0;
                clearTimetable();
            }
            
            // Refresh the combination selector
            populateCombinationSelector();
            
            // Clear selection
            selector.value = '';
            updateCombinationActionButtons();
            
            // Update export controls since selections may have changed
            updateExportControls();
            
            // Auto-save session
            autoSaveSession();
        }
        
        // Update bookmarked combinations display
        function updateBookmarkedCombinationsDisplay() {
            const bookmarkedContainer = document.getElementById('bookmarkedCombinations');
            const bookmarkedList = document.getElementById('bookmarkedList');
            
            // Filter out deleted combinations from bookmarked ones
            const activeBookmarked = Array.from(bookmarkedCombinations).filter(index => !deletedCombinations.has(index));
            
            if (activeBookmarked.length === 0) {
                bookmarkedContainer.style.display = 'none';
                return;
            }
            
            bookmarkedContainer.style.display = 'block';
            
            // Create quick access buttons for bookmarked combinations
            bookmarkedList.innerHTML = activeBookmarked
                .sort((a, b) => a - b) // Sort by combination number
                .map(index => {
                    const combination = validCombinations[index];
                    const conflictCount = countTimeConflicts(combination);
                    const emptyDaysCount = countEmptyDays(combination);
                    const conflictText = conflictCount > 0 ? ` (${conflictCount} conflicts)` : '';
                    const emptyDaysText = emptyDaysCount > 0 ? ` (${emptyDaysCount} empty days)` : '';
                    
                    return `
                        <button onclick="selectBookmarkedCombination(${index})" 
                                style="padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 2px;"
                                title="Click to view this combination">
                            ‚≠ê ${index + 1}${conflictText}${emptyDaysText}
                        </button>
                    `;
                }).join('');
        }
        
        // Select and display a bookmarked combination
        function selectBookmarkedCombination(index) {
            const selector = document.getElementById('combinationSelector');
            selector.value = index;
            currentCombinationIndex = index;
            displayCombinationInTimetable();
            updateCombinationActionButtons();
        }
        
        // Select combination from the combinations list
        function selectCombinationFromList(index) {
            const selector = document.getElementById('combinationSelector');
            selector.value = index;
            currentCombinationIndex = index;
            displayCombinationInTimetable();
            updateCombinationActionButtons();
        }
        
        // Toggle bookmark from the combinations list
        function toggleBookmarkFromList(index) {
            if (bookmarkedCombinations.has(index)) {
                bookmarkedCombinations.delete(index);
            } else {
                bookmarkedCombinations.add(index);
            }
            
            // Refresh displays
            populateCombinationSelector();
            generateTimetableCombinations();
            
            // Auto-save session
            autoSaveSession();
        }
        
        // Delete combination from the combinations list
        function deleteCombinationFromList(index) {
            const confirmDelete = confirm(`Are you sure you want to delete Combination ${index + 1}? This action cannot be undone.`);
            
            if (!confirmDelete) {
                return;
            }
            
            // Add to deleted combinations
            deletedCombinations.add(index);
            
            // Remove from bookmarked if it was bookmarked
            bookmarkedCombinations.delete(index);
            
            // Remove from export selections if it was selected for export
            selectedCombinationsForExport.delete(index);
            
            // Clear current timetable if it was showing the deleted combination
            if (currentCombinationIndex === index) {
                currentCombinationIndex = 0;
                clearTimetable();
                const selector = document.getElementById('combinationSelector');
                selector.value = '';
            }
            
            // Refresh displays
            populateCombinationSelector();
            generateTimetableCombinations();
            updateExportControls();
            
            // Auto-save session
            autoSaveSession();
        }
        
        // Display selected combination in timetable
        function displayCombinationInTimetable() {
            const selector = document.getElementById('combinationSelector');
            const selectedIndex = parseInt(selector.value);
            
            if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= validCombinations.length || deletedCombinations.has(selectedIndex)) {
                clearTimetable();
                updateCombinationActionButtons();
                return;
            }
            
            currentCombinationIndex = selectedIndex;
            clearTimetable();
            
            const combination = validCombinations[selectedIndex];
            console.log('Displaying combination:', selectedIndex + 1, combination);
            
            combination.forEach(lectureGroup => {
                console.log('Placing lecture group:', lectureGroup);
                lectureGroup.forEach(lecture => {
                    placeLectureInTimetable(lecture);
                });
            });
            
            // Update combination action buttons
            updateCombinationActionButtons();
        }
        
        // Toggle time slot lock
        function toggleTimeSlotLock(day, hour) {
            const cellId = `cell_${day}_${hour}`;
            const cell = document.getElementById(cellId);
            const slotKey = `${day}_${hour}`;
            
            if (!cell) return;
            
            // Don't allow locking if cell has a lecture
            if (cell.innerHTML.trim() !== '' && !cell.classList.contains('locked')) {
                return;
            }
            
            if (lockedTimeSlots.has(slotKey)) {
                // Unlock the slot
                lockedTimeSlots.delete(slotKey);
                cell.classList.remove('locked');
                cell.innerHTML = '';
            } else {
                // Lock the slot
                lockedTimeSlots.add(slotKey);
                cell.classList.add('locked');
                cell.innerHTML = '<div class="locked-indicator">üîí</div>';
            }
            
            updateLockedSlotsDisplay();
            
            // Regenerate combinations if there are selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Update locked slots display
        function updateLockedSlotsDisplay() {
            const container = document.getElementById('lockedSlotsContainer');
            const slotsDiv = document.getElementById('lockedSlots');
            
            if (lockedTimeSlots.size === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            
            const lockedSlotsList = Array.from(lockedTimeSlots).map(slotKey => {
                const [day, hour] = slotKey.split('_');
                const nextHour = parseInt(hour) + 1;
                return `<span style="display: inline-block; margin: 2px; padding: 4px 8px; background: #fed7d7; color: #e53e3e; border-radius: 12px; font-size: 12px; border: 1px solid #e53e3e;">
                    ${day} ${hour}:00-${nextHour}:00 üîí
                </span>`;
            }).join('');
            
            slotsDiv.innerHTML = lockedSlotsList;
        }
        
        // Clear all locked slots
        function clearAllLockedSlots() {
            lockedTimeSlots.clear();
            
            // Remove visual indicators
            timeHours.forEach(hour => {
                days.forEach(day => {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    if (cell && cell.classList.contains('locked')) {
                        cell.classList.remove('locked');
                        if (cell.innerHTML.includes('locked-indicator')) {
                            cell.innerHTML = '';
                        }
                    }
                });
            });
            
            updateLockedSlotsDisplay();
            
            // Regenerate combinations if there are selected lectures
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Clear the timetable - CSS Grid version
        function clearTimetable() {
            timeHours.forEach(hour => {
                days.forEach(day => {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    const slotKey = `${day}_${hour}`;
                    
                    if (cell) {
                        if (lockedTimeSlots.has(slotKey)) {
                            // Keep locked slots
                            cell.className = 'timetable-cell locked';
                            cell.innerHTML = '<div class="locked-indicator">üîí</div>';
                        } else {
                            // Clear unlocked slots
                            cell.innerHTML = '';
                            cell.className = 'timetable-cell';
                            cell.style.pointerEvents = '';
                        }
                        cell.classList.remove('occupied-continuation');
                        
                        // Remove any conflict indicators
                        const conflictIndicators = cell.querySelectorAll('.conflict-indicator');
                        conflictIndicators.forEach(indicator => indicator.remove());
                    }
                });
            });
            console.log('Modern timetable cleared, locked slots preserved');
        }
        
        // Place a lecture in the timetable with conflict visualization
        function placeLectureInTimetable(lecture) {
            if (!lecture || !lecture.Day || lecture.StartHour === undefined) {
                console.error('Invalid lecture data:', lecture);
                return;
            }
            
            const conflicts = findConflictsForLecture(lecture);
            const hasConflicts = conflicts.length > 0;
            
            if (hasConflicts) {
                // Handle conflicted lecture with new algorithm
                placeConflictedLecture(lecture, conflicts);
            } else {
                // Handle non-conflicted lecture normally
                placeNonConflictedLecture(lecture);
            }
        }
        
        // Place non-conflicted lecture (original logic)
        function placeNonConflictedLecture(lecture) {
            const day = lecture.Day;
            const startHour = lecture.StartHour;
            const endHour = lecture.EndHour;
            const duration = endHour - startHour;
            const lectureColor = getLectureColor(lecture.Code);
            
            const firstCellId = `cell_${day}_${startHour}`;
            const firstCell = document.getElementById(firstCellId);
            
            if (firstCell) {
                const cellHeight = 60;
                const blockHeight = (duration * cellHeight) - 4;
                
                const lectureBlock = document.createElement('div');
                lectureBlock.className = 'lecture-block multi-row';
                lectureBlock.style.cssText = `
                    height: ${blockHeight}px;
                    background: ${lectureColor.bg};
                    color: ${lectureColor.text};
                    border-radius: 8px;
                    padding: 12px 8px;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    text-align: center;
                    position: absolute;
                    width: 100%;
                    left: 0;
                    z-index: 10;
                `;
                
                lectureBlock.innerHTML = `
                    <div style="font-size: ${duration >= 3 ? '14px' : '12px'}; font-weight: bold; margin-bottom: 4px;">${lecture.Code}</div>
                    <div style="font-size: ${duration >= 3 ? '12px' : '10px'}; opacity: 0.9; margin-bottom: 4px;">Sec ${lecture.Section}</div>
                    <div style="font-size: ${duration >= 3 ? '11px' : '9px'}; opacity: 0.8; margin-bottom: 3px;">${lecture.Lecturer || 'TBA'}</div>
                    <div style="font-size: ${duration >= 3 ? '10px' : '8px'}; opacity: 0.7; margin-bottom: 3px;">${lecture.Room || 'TBA'}</div>
                    <div style="font-size: ${duration >= 3 ? '10px' : '8px'}; opacity: 0.7; margin-top: 4px;">${startHour}:00-${endHour}:00</div>
                `;
                
                firstCell.appendChild(lectureBlock);
                
                // Mark subsequent cells as occupied
                for (let hour = startHour + 1; hour < endHour; hour++) {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    if (cell) {
                        cell.style.pointerEvents = 'none';
                        cell.classList.add('occupied-continuation');
                    }
                }
            }
        }
        
        // Handle conflicted lectures with new algorithm
        function placeConflictedLecture(lecture, conflicts) {
            // Find all conflicted time intervals for this specific lecture
            const conflictedHours = new Set();
            
            conflicts.forEach(conflictLecture => {
                const overlapStart = Math.max(lecture.StartHour, conflictLecture.StartHour);
                const overlapEnd = Math.min(lecture.EndHour, conflictLecture.EndHour);
                
                for (let hour = overlapStart; hour < overlapEnd; hour++) {
                    conflictedHours.add(hour);
                }
            });
            
            // Find non-conflicted hours for this lecture
            const nonConflictedHours = [];
            for (let hour = lecture.StartHour; hour < lecture.EndHour; hour++) {
                if (!conflictedHours.has(hour)) {
                    nonConflictedHours.push(hour);
                }
            }
            
            // Create lecture blocks for non-conflicted time segments
            if (nonConflictedHours.length > 0) {
                const segments = getConsecutiveSegments(nonConflictedHours);
                segments.forEach(segment => {
                    createLectureSegment(lecture, segment.start, segment.end);
                });
            }
            
            // Create conflict boxes for conflicted hours (only once per unique conflict set)
            const processedConflictHours = new Set();
            
            conflictedHours.forEach(hour => {
                if (!processedConflictHours.has(hour)) {
                    const cellId = `cell_${lecture.Day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    
                    // Check if conflict box already exists for this hour
                    if (cell && !cell.querySelector('.conflict-box')) {
                        // Find all lectures that conflict at this specific hour
                        const conflictingLectures = [lecture];
                        conflicts.forEach(c => {
                            if (hour >= c.StartHour && hour < c.EndHour) {
                                conflictingLectures.push(c);
                            }
                        });
                        
                        // Find consecutive conflicted hours for this conflict set
                        const conflictSegmentHours = [];
                        for (let h = hour; h < 24; h++) {
                            if (conflictedHours.has(h)) {
                                conflictSegmentHours.push(h);
                                processedConflictHours.add(h);
                            } else {
                                break;
                            }
                        }
                        
                        createConflictBox(lecture.Day, conflictSegmentHours[0], conflictSegmentHours[conflictSegmentHours.length-1] + 1, conflictingLectures);
                    }
                }
            });
        }
        
        // Get consecutive segments from array of hours
        function getConsecutiveSegments(hours) {
            if (hours.length === 0) return [];
            
            hours.sort((a, b) => a - b);
            const segments = [];
            let segmentStart = hours[0];
            let segmentEnd = hours[0] + 1;
            
            for (let i = 1; i < hours.length; i++) {
                if (hours[i] === hours[i-1] + 1) {
                    segmentEnd = hours[i] + 1;
                } else {
                    segments.push({ start: segmentStart, end: segmentEnd });
                    segmentStart = hours[i];
                    segmentEnd = hours[i] + 1;
                }
            }
            
            segments.push({ start: segmentStart, end: segmentEnd });
            return segments;
        }
        
        // Create lecture segment for specific time range
        function createLectureSegment(lecture, startHour, endHour) {
            const lectureColor = getLectureColor(lecture.Code);
            const duration = endHour - startHour;
            const cellHeight = 60;
            const blockHeight = (duration * cellHeight) - 4;
            
            const firstCellId = `cell_${lecture.Day}_${startHour}`;
            const firstCell = document.getElementById(firstCellId);
            
            if (firstCell) {
                const lectureBlock = document.createElement('div');
                lectureBlock.className = 'lecture-block multi-row';
                lectureBlock.style.cssText = `
                    height: ${blockHeight}px;
                    background: ${lectureColor.bg};
                    color: ${lectureColor.text};
                    border-radius: 8px;
                    padding: 12px 8px;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    text-align: center;
                    position: absolute;
                    width: 100%;
                    left: 0;
                    z-index: 10;
                `;
                
                lectureBlock.innerHTML = `
                    <div style="font-size: ${duration >= 3 ? '14px' : '12px'}; font-weight: bold; margin-bottom: 4px;">${lecture.Code}</div>
                    <div style="font-size: ${duration >= 3 ? '12px' : '10px'}; opacity: 0.9; margin-bottom: 4px;">Sec ${lecture.Section}</div>
                    <div style="font-size: ${duration >= 3 ? '11px' : '9px'}; opacity: 0.8; margin-bottom: 3px;">${lecture.Lecturer || 'TBA'}</div>
                    <div style="font-size: ${duration >= 3 ? '10px' : '8px'}; opacity: 0.7; margin-bottom: 3px;">${lecture.Room || 'TBA'}</div>
                    <div style="font-size: ${duration >= 3 ? '10px' : '8px'}; opacity: 0.7; margin-top: 4px;">${startHour}:00-${endHour}:00</div>
                `;
                
                firstCell.appendChild(lectureBlock);
                
                // Mark subsequent cells as occupied
                for (let hour = startHour + 1; hour < endHour; hour++) {
                    const cellId = `cell_${lecture.Day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    if (cell) {
                        cell.style.pointerEvents = 'none';
                        cell.classList.add('occupied-continuation');
                    }
                }
            }
        }
        
        // Create conflict box showing conflicted lectures
        function createConflictBox(day, startHour, endHour, conflictingLectures) {
            const duration = endHour - startHour;
            const cellHeight = 60;
            const blockHeight = (duration * cellHeight) - 4;
            
            const firstCellId = `cell_${day}_${startHour}`;
            const firstCell = document.getElementById(firstCellId);
            
            if (firstCell) {
                const conflictBlock = document.createElement('div');
                conflictBlock.className = 'lecture-block multi-row conflict-box';
                conflictBlock.style.cssText = `
                    height: ${blockHeight}px;
                    background: linear-gradient(135deg, #dc3545, #c82333);
                    color: white;
                    border: 2px solid #dc3545;
                    border-radius: 8px;
                    padding: 12px 8px;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    text-align: center;
                    position: absolute;
                    width: 100%;
                    left: 0;
                    z-index: 20;
                    animation: conflictPulse 2s infinite;
                `;
                
                const lectureCodes = conflictingLectures.map(l => l.Code).join(' & ');
                
                conflictBlock.innerHTML = `
                    <div style="font-size: ${duration >= 2 ? '14px' : '12px'}; font-weight: bold; margin-bottom: 6px;">‚ö†Ô∏è CONFLICT</div>
                    <div style="font-size: ${duration >= 2 ? '12px' : '10px'}; opacity: 0.9; margin-bottom: 4px;">${lectureCodes}</div>
                    <div style="font-size: ${duration >= 2 ? '10px' : '8px'}; opacity: 0.8; margin-top: 4px;">${startHour}:00-${endHour}:00</div>
                `;
                
                firstCell.appendChild(conflictBlock);
                
                // Mark subsequent cells as occupied
                for (let hour = startHour + 1; hour < endHour; hour++) {
                    const cellId = `cell_${day}_${hour}`;
                    const cell = document.getElementById(cellId);
                    if (cell) {
                        cell.style.pointerEvents = 'none';
                        cell.classList.add('occupied-continuation');
                    }
                }
            }
        }
        
        // Find conflicts for a specific lecture within the current combination
        function findConflictsForLecture(targetLecture) {
            if (!validCombinations[currentCombinationIndex]) return [];
            
            const currentCombination = validCombinations[currentCombinationIndex];
            const conflicts = [];
            
            // Get all lectures in the current combination
            const allLecturesInCombination = [];
            currentCombination.forEach(lectureGroup => {
                lectureGroup.forEach(lecture => {
                    allLecturesInCombination.push(lecture);
                });
            });
            
            // Check for time overlaps with other lectures
            allLecturesInCombination.forEach(otherLecture => {
                if (otherLecture.Code !== targetLecture.Code && 
                    otherLecture.Day === targetLecture.Day) {
                    
                    // Check if time ranges overlap
                    const targetStart = targetLecture.StartHour;
                    const targetEnd = targetLecture.EndHour;
                    const otherStart = otherLecture.StartHour;
                    const otherEnd = otherLecture.EndHour;
                    
                    if (targetStart < otherEnd && otherStart < targetEnd) {
                        conflicts.push(otherLecture);
                    }
                }
            });
            
            return conflicts;
        }
        
        // Generate combinations respecting alternative course groups
        function generateAlternativeCombinations(processedLectureOptions) {
            const combinations = [];
            
            function generateRecursive(optionIndex, currentCombination) {
                if (optionIndex >= processedLectureOptions.length) {
                    combinations.push([...currentCombination]);
                    return;
                }
                
                const currentOptionSet = processedLectureOptions[optionIndex];
                
                // For each course option in this set (alternative group or single course)
                for (const courseOption of currentOptionSet) {
                    const courseCode = courseOption.courseCode;
                    const sections = courseOption.sections;
                    
                    // Skip if no sections available for this course
                    if (sections.length === 0) continue;
                    
                    // For each section of this course
                    for (const section of sections) {
                        // Add this section to the combination and recurse
                        currentCombination.push(section);
                        generateRecursive(optionIndex + 1, currentCombination);
                        currentCombination.pop();
                    }
                }
            }
            
            generateRecursive(0, []);
            return combinations;
        }
        
        // Generate all possible combinations from arrays
        function generateCombinations(arrays) {
            if (arrays.length === 0) return [[]];
            if (arrays.length === 1) return arrays[0].map(item => [item]);
            
            const result = [];
            const restCombinations = generateCombinations(arrays.slice(1));
            
            for (const item of arrays[0]) {
                for (const combination of restCombinations) {
                    result.push([item, ...combination]);
                }
            }
            
            return result;
        }
        
        // Check if a combination has time conflicts - updated for multiple time slots and locked slots
        // Global variable to store maximum allowed conflicts (already declared above)
        
        function countTimeConflicts(combination) {
            const allTimeSlots = [];
            
            // Extract all time slots from the combination
            combination.forEach(lectureGroup => {
                const lectureCode = lectureGroup[0].Code;
                const lectureSection = lectureGroup[0].Section;
                
                lectureGroup.forEach(lecture => {
                    // Add each hour as a separate slot for precise conflict detection
                    for (let hour = lecture.StartHour; hour < lecture.EndHour; hour++) {
                        allTimeSlots.push({
                            Code: lectureCode,
                            Section: lectureSection,
                            Day: lecture.Day,
                            Hour: hour,
                            StartHour: lecture.StartHour,
                            EndHour: lecture.EndHour
                        });
                    }
                });
            });
            
            let conflictHours = 0;
            
            // Only count conflicts between lectures (not with locked slots, since those are filtered out)
            for (let i = 0; i < allTimeSlots.length; i++) {
                for (let j = i + 1; j < allTimeSlots.length; j++) {
                    const slot1 = allTimeSlots[i];
                    const slot2 = allTimeSlots[j];
                    
                    // Skip if same lecture
                    if (slot1.Code === slot2.Code && slot1.Section === slot2.Section) {
                        continue;
                    }
                    
                    // Check if same day and hour (conflict)
                    if (slot1.Day === slot2.Day && slot1.Hour === slot2.Hour) {
                        conflictHours++;
                        console.log(`Conflict detected: ${slot1.Code} vs ${slot2.Code} at ${slot1.Day} ${slot1.Hour}:00`);
                        break; // Count each conflicting hour only once
                    }
                }
            }
            
            return conflictHours;
        }
        
        // Count empty days in a combination
        function countEmptyDays(combination) {
            const occupiedDays = new Set();
            
            combination.forEach(lectureGroup => {
                lectureGroup.forEach(lecture => {
                    if (lecture.Day) {
                        occupiedDays.add(lecture.Day);
                    }
                });
            });
            
            const totalDays = days.length; // days array: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
            const emptyDaysCount = totalDays - occupiedDays.size;
            
            return emptyDaysCount;
        }
        
        // Filter combinations based on all validation criteria
        function filterValidCombinations(combinations) {
            return combinations.filter(combination => {
                const conflictCount = countTimeConflicts(combination);
                const emptyDaysCount = countEmptyDays(combination);
                const hasLockedConflicts = hasLockedTimeSlotConflicts(combination);
                
                // Check all criteria
                const meetsConflictCriteria = conflictCount <= maxAllowedConflicts;
                const meetsEmptyDaysCriteria = emptyDaysCount >= minRequiredEmptyDays;
                const meetsLockedSlotsCriteria = !hasLockedConflicts;
                
                return meetsConflictCriteria && meetsEmptyDaysCriteria && meetsLockedSlotsCriteria;
            });
        }
        
        // Check if combination conflicts with locked time slots
        function hasLockedTimeSlotConflicts(combination) {
            if (lockedTimeSlots.size === 0) return false;
            
            for (const lectureGroup of combination) {
                for (const lecture of lectureGroup) {
                    // Check each hour of the lecture
                    for (let hour = lecture.StartHour; hour < lecture.EndHour; hour++) {
                        const slotKey = `${lecture.Day}_${hour}`;
                        if (lockedTimeSlots.has(slotKey)) {
                            return true; // Found a conflict with locked slots
                        }
                    }
                }
            }
            
            return false; // No conflicts with locked slots
        }
        
        function hasTimeConflict(combination) {
            const conflicts = countTimeConflicts(combination);
            return conflicts > maxAllowedConflicts;
        }
        
        // Check if two time ranges overlap
        function timeRangesOverlap(range1, range2) {
            return range1.start < range2.end && range2.start < range1.end;
        }
        
        // Find conflicts for a specific lecture within the current combination
        function findConflictsForLecture(targetLecture) {
            if (!validCombinations[currentCombinationIndex]) return [];
            
            const currentCombination = validCombinations[currentCombinationIndex];
            const conflicts = [];
            
            // Get all lectures in the current combination
            const allLecturesInCombination = [];
            currentCombination.forEach(lectureGroup => {
                lectureGroup.forEach(lecture => {
                    allLecturesInCombination.push(lecture);
                });
            });
            
            // Check for time overlaps with other lectures
            allLecturesInCombination.forEach(otherLecture => {
                if (otherLecture.Code !== targetLecture.Code && 
                    otherLecture.Day === targetLecture.Day) {
                    
                    // Check if time ranges overlap
                    const targetStart = targetLecture.StartHour;
                    const targetEnd = targetLecture.EndHour;
                    const otherStart = otherLecture.StartHour;
                    const otherEnd = otherLecture.EndHour;
                    
                    if (targetStart < otherEnd && otherStart < targetEnd) {
                        conflicts.push(otherLecture);
                    }
                }
            });
            
            return conflicts;
        }
        
        // Global variable to store maximum allowed conflicts
        let maxAllowedConflicts = 0;
        
        // Global variable to store minimum required empty days
        let minRequiredEmptyDays = 0;
        
        // Update conflict settings when slider changes
        function updateConflictSettings() {
            const slider = document.getElementById('maxConflicts');
            const valueDisplay = document.getElementById('conflictValue');
            
            maxAllowedConflicts = parseInt(slider.value);
            valueDisplay.textContent = maxAllowedConflicts;
            
            console.log('Maximum allowed conflicts set to:', maxAllowedConflicts);
            
            // Regenerate combinations if lectures are already selected
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }
        
        // Update empty days settings when slider changes
        function updateEmptyDaysSettings() {
            const slider = document.getElementById('minEmptyDays');
            const valueDisplay = document.getElementById('emptyDaysValue');
            
            minRequiredEmptyDays = parseInt(slider.value);
            valueDisplay.textContent = minRequiredEmptyDays;
            
            console.log('Minimum required empty days set to:', minRequiredEmptyDays);
            
            // Regenerate combinations if lectures are already selected
            if (selectedLectures.length > 0) {
                generateTimetableCombinations();
            }
        }

        // Toggle Selected Lectures visibility
        function toggleSelectedLecturesVisibility() {
            const lecturesDiv = document.getElementById('selectedLectures');
            const button = document.getElementById('minimizeSelectedButton');
            const isMinimized = lecturesDiv.style.display === 'none';
            
            if (isMinimized) {
                // Expand
                lecturesDiv.style.display = 'block';
                button.innerHTML = '‚ñ≤';
                button.title = 'Minimize Selected Lectures';
            } else {
                // Minimize
                lecturesDiv.style.display = 'none';
                button.innerHTML = '‚ñº';
                button.title = 'Show Selected Lectures';
            }
        }

        // Export functionality functions
        
        // Toggle combination selection for export
        function toggleCombinationSelection(combinationIndex) {
            // Don't allow selection of deleted combinations
            if (deletedCombinations.has(combinationIndex)) {
                return;
            }
            
            if (selectedCombinationsForExport.has(combinationIndex)) {
                selectedCombinationsForExport.delete(combinationIndex);
            } else {
                selectedCombinationsForExport.add(combinationIndex);
            }
            
            updateExportControls();
        }
        
        // Select all combinations for export
        function selectAllCombinationsForExport() {
            selectedCombinationsForExport.clear();
            for (let i = 0; i < validCombinations.length; i++) {
                // Only select non-deleted combinations
                if (!deletedCombinations.has(i)) {
                    selectedCombinationsForExport.add(i);
                }
            }
            
            updateExportControls();
            updateCombinationCheckboxes();
        }
        
        // Clear all combination selections
        function clearAllCombinationSelections() {
            selectedCombinationsForExport.clear();
            updateExportControls();
            updateCombinationCheckboxes();
        }
        
        // Update export controls state
        function updateExportControls() {
            const exportButton = document.querySelector('button[onclick="exportSelectedCombinations()"]');
            const selectedCountDisplay = document.getElementById('selectedCountDisplay');
            const count = selectedCombinationsForExport.size;
            
            if (exportButton) {
                exportButton.disabled = count === 0;
                exportButton.style.opacity = count === 0 ? '0.5' : '1';
                exportButton.style.cursor = count === 0 ? 'not-allowed' : 'pointer';
            }
            
            if (selectedCountDisplay) {
                selectedCountDisplay.textContent = `${count} combination${count !== 1 ? 's' : ''} selected for export`;
            }
        }
        
        // Update checkbox states in combination list
        function updateCombinationCheckboxes() {
            const checkboxes = document.querySelectorAll('.combination-export-checkbox');
            checkboxes.forEach(checkbox => {
                const index = parseInt(checkbox.dataset.index);
                // Only update checkboxes for non-deleted combinations
                if (!deletedCombinations.has(index)) {
                    checkbox.checked = selectedCombinationsForExport.has(index);
                }
            });
        }
        
        // Export selected combinations as PNG
        async function exportSelectedCombinations() {
            // Filter out any deleted combinations from the selection
            selectedCombinationsForExport.forEach(index => {
                if (deletedCombinations.has(index)) {
                    selectedCombinationsForExport.delete(index);
                }
            });
            
            if (selectedCombinationsForExport.size === 0) {
                alert('Please select at least one combination to export.');
                return;
            }
            
            const exportStatus = document.getElementById('exportStatus');
            const selectedIndices = Array.from(selectedCombinationsForExport).sort((a, b) => a - b);
            
            exportStatus.textContent = 'Preparing export...';
            exportStatus.style.color = '#007bff';
            
            try {
                for (let i = 0; i < selectedIndices.length; i++) {
                    const combinationIndex = selectedIndices[i];
                    exportStatus.textContent = `üì± Displaying and exporting combination ${i + 1} of ${selectedIndices.length}...`;
                    exportStatus.style.fontWeight = 'bold';
                    
                    // Switch to this combination temporarily
                    const originalIndex = currentCombinationIndex;
                    currentCombinationIndex = combinationIndex;
                    
                    // Update the dropdown selector to match the current combination
                    const selector = document.getElementById('combinationSelector');
                    if (selector) {
                        selector.value = combinationIndex;
                    }
                    
                    displayCombinationInTimetable();
                    
                    // Wait a moment for the DOM to update and let user see the combination
                    await new Promise(resolve => setTimeout(resolve, 800));
                    
                    // Update status to show we're now capturing
                    exportStatus.textContent = `üì∏ Capturing combination ${i + 1} of ${selectedIndices.length} as PNG...`;
                    
                    // Capture the timetable
                    await exportTimetableAsPNG(combinationIndex + 1);
                    
                    // Brief pause before moving to next combination
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    // Restore original combination if it was different
                    if (originalIndex !== combinationIndex) {
                        currentCombinationIndex = originalIndex;
                        
                        // Restore the original dropdown value
                        if (selector) {
                            selector.value = originalIndex;
                        }
                        
                        displayCombinationInTimetable();
                    }
                }
                
                exportStatus.textContent = `‚úÖ Successfully exported ${selectedIndices.length} combination${selectedIndices.length !== 1 ? 's' : ''}!`;
                exportStatus.style.color = '#28a745';
                exportStatus.style.fontWeight = 'bold';
                
                // Clear status after 3 seconds
                setTimeout(() => {
                    exportStatus.textContent = '';
                    exportStatus.style.fontWeight = 'normal';
                }, 3000);
                
            } catch (error) {
                console.error('Export error:', error);
                exportStatus.textContent = '‚ùå Export failed. Please try again.';
                exportStatus.style.color = '#dc3545';
                exportStatus.style.fontWeight = 'bold';
                
                setTimeout(() => {
                    exportStatus.textContent = '';
                    exportStatus.style.fontWeight = 'normal';
                }, 3000);
            }
        }
        
        // Export timetable as PNG using html2canvas
        async function exportTimetableAsPNG(combinationNumber) {
            const timetableContainer = document.querySelector('.timetable-container');
            
            if (!timetableContainer) {
                throw new Error('Timetable container not found');
            }

            // Create temporary export container
            const exportContainer = await createExportContainer(combinationNumber);
            
            try {
                // Configure html2canvas options
                const canvas = await html2canvas(exportContainer, {
                    backgroundColor: '#ffffff',
                    scale: 2, // Higher resolution
                    useCORS: true,
                    allowTaint: false,
                    width: exportContainer.scrollWidth,
                    height: exportContainer.scrollHeight,
                    windowWidth: exportContainer.scrollWidth,
                    windowHeight: exportContainer.scrollHeight
                });
                
                // Convert canvas to blob and download
                canvas.toBlob(blob => {
                    if (blob) {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = `timetable-combination-${combinationNumber}.png`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                    }
                }, 'image/png', 1.0);
                
            } catch (error) {
                console.error('Error capturing timetable:', error);
                throw error;
            } finally {
                // Clean up temporary container
                if (exportContainer && exportContainer.parentNode) {
                    exportContainer.parentNode.removeChild(exportContainer);
                }
            }
        }

        // Create a temporary container for export with timetable and combination details
        async function createExportContainer(combinationNumber) {
            const timetableContainer = document.querySelector('.timetable-container');
            const combinationIndex = combinationNumber - 1;
            const combination = validCombinations[combinationIndex];
            
            if (!combination) {
                throw new Error('Combination not found');
            }

            // Create main export container
            const exportContainer = document.createElement('div');
            exportContainer.style.cssText = `
                position: absolute;
                top: -10000px;
                left: -10000px;
                width: 1400px;
                background: white;
                padding: 30px;
                font-family: Arial, sans-serif;
                box-sizing: border-box;
            `;

            // Create header section
            const headerSection = document.createElement('div');
            headerSection.style.cssText = `
                text-align: center;
                margin-bottom: 25px;
                padding-bottom: 20px;
                border-bottom: 2px solid #007bff;
            `;

            const title = document.createElement('h1');
            title.textContent = 'University Schedule Creator';
            title.style.cssText = `
                color: #333;
                font-size: 28px;
                margin: 0 0 10px 0;
                font-weight: bold;
            `;

            const subtitle = document.createElement('h2');
            subtitle.textContent = `Timetable - Combination ${combinationNumber}`;
            subtitle.style.cssText = `
                color: #007bff;
                font-size: 20px;
                margin: 0;
                font-weight: 600;
            `;

            headerSection.appendChild(title);
            headerSection.appendChild(subtitle);

            // Create content section with two columns
            const contentSection = document.createElement('div');
            contentSection.style.cssText = `
                display: flex;
                gap: 30px;
                align-items: flex-start;
            `;

            // Left column - Timetable
            const timetableColumn = document.createElement('div');
            timetableColumn.style.cssText = `
                flex: 2;
                min-width: 800px;
            `;

            // Clone the timetable
            const timetableClone = timetableContainer.cloneNode(true);
            timetableClone.style.cssText = `
                border-radius: 12px;
                overflow: hidden;
                box-shadow: 0 4px 20px rgba(0,0,0,0.1);
                margin: 0;
            `;

            timetableColumn.appendChild(timetableClone);

            // Right column - Combination details
            const detailsColumn = document.createElement('div');
            detailsColumn.style.cssText = `
                flex: 1;
                min-width: 400px;
                background: #f8f9fa;
                border-radius: 10px;
                padding: 20px;
                border: 1px solid #e9ecef;
            `;

            // Calculate conflict information
            const conflictCount = countTimeConflicts(combination);
            const isValidCombination = conflictCount <= maxAllowedConflicts;

            // Create details content
            const detailsTitle = document.createElement('h3');
            detailsTitle.textContent = 'Combination Details';
            detailsTitle.style.cssText = `
                color: #333;
                font-size: 18px;
                margin: 0 0 15px 0;
                font-weight: bold;
                border-bottom: 1px solid #dee2e6;
                padding-bottom: 10px;
            `;

            // Conflict status
            const conflictStatus = document.createElement('div');
            const conflictText = conflictCount === 0 ? 'No conflicts' : 
                                `${conflictCount} conflict${conflictCount > 1 ? 's' : ''}${!isValidCombination ? ' (EXCEEDS LIMIT)' : ''}`;
            const statusColor = conflictCount === 0 ? '#28a745' : (isValidCombination ? '#ffc107' : '#dc3545');
            const statusBgColor = conflictCount === 0 ? '#d4edda' : (isValidCombination ? '#fff3cd' : '#f8d7da');
            
            conflictStatus.innerHTML = `
                <div style="
                    background: ${statusBgColor};
                    color: ${statusColor};
                    padding: 8px 12px;
                    border-radius: 5px;
                    font-weight: bold;
                    margin-bottom: 20px;
                    text-align: center;
                    border: 1px solid ${statusColor};
                ">${conflictText}</div>
            `;

            // Course list
            const courseList = document.createElement('div');
            courseList.innerHTML = combination.map(lectureGroup => {
                const firstLecture = lectureGroup[0];
                const lectureColor = getLectureColor(firstLecture.Code);
                
                return `
                    <div style="
                        margin-bottom: 15px;
                        padding: 12px;
                        background: white;
                        border-radius: 8px;
                        border-left: 4px solid #007bff;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    ">
                        <div style="
                            font-weight: bold;
                            color: #007bff;
                            font-size: 14px;
                            margin-bottom: 5px;
                        ">${firstLecture.Code} - Section ${firstLecture.Section}</div>
                        
                        <div style="
                            color: #666;
                            font-size: 13px;
                            margin-bottom: 5px;
                            line-height: 1.3;
                        ">${firstLecture.Name}</div>
                        
                        <div style="
                            color: #333;
                            font-size: 12px;
                            margin-bottom: 8px;
                            font-weight: 500;
                        ">${firstLecture.Lecturer || 'TBA'}</div>
                        
                        <div style="
                            font-size: 11px;
                            color: #666;
                            margin-bottom: 5px;
                        ">Schedule:</div>
                        
                        ${lectureGroup.map(lecture => `
                            <div style="margin-left: 10px; margin-bottom: 4px;">
                                <div style="
                                    color: #28a745;
                                    font-weight: bold;
                                    font-size: 11px;
                                ">${lecture.Day} ${lecture.StartHour.toString().padStart(2, '0')}:00-${lecture.EndHour.toString().padStart(2, '0')}:00</div>
                                <div style="
                                    color: #6c757d;
                                    font-size: 10px;
                                    margin-left: 10px;
                                ">Room: ${lecture.Room || 'TBA'}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }).join('');

            // Export info footer
            const exportInfo = document.createElement('div');
            exportInfo.style.cssText = `
                margin-top: 20px;
                padding-top: 15px;
                border-top: 1px solid #dee2e6;
                font-size: 11px;
                color: #666;
                text-align: center;
            `;
            
            const exportDate = new Date().toLocaleString();
            exportInfo.innerHTML = `
                <div>Exported: ${exportDate}</div>
                <div style="margin-top: 3px;">Max Conflicts Allowed: ${maxAllowedConflicts}</div>
            `;

            // Assemble details column
            detailsColumn.appendChild(detailsTitle);
            detailsColumn.appendChild(conflictStatus);
            detailsColumn.appendChild(courseList);
            detailsColumn.appendChild(exportInfo);

            // Assemble content section
            contentSection.appendChild(timetableColumn);
            contentSection.appendChild(detailsColumn);

            // Assemble export container
            exportContainer.appendChild(headerSection);
            exportContainer.appendChild(contentSection);

            // Add to DOM temporarily
            document.body.appendChild(exportContainer);

            return exportContainer;
        }
        </script>
</body>
</html>